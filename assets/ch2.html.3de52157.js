import{_ as e,o as t,c as o,a,F as p,d as n}from"./app.a957722f.js";const c={},r=n(`<h1 id="you-don-t-know-js-up-going" tabindex="-1"><a class="header-anchor" href="#you-don-t-know-js-up-going" aria-hidden="true">#</a> You Don&#39;t Know JS: Up &amp; Going</h1><h1 id="chapter-2-into-javascript" tabindex="-1"><a class="header-anchor" href="#chapter-2-into-javascript" aria-hidden="true">#</a> Chapter 2: Into JavaScript</h1><p>In the previous chapter, I introduced the basic building blocks of programming, such as variables, loops, conditionals, and functions. Of course, all the code shown has been in JavaScript. But in this chapter, we want to focus specifically on things you need to know about JavaScript to get up and going as a JS developer.</p><p>We will introduce quite a few concepts in this chapter that will not be fully explored until subsequent <em>YDKJS</em> books. You can think of this chapter as an overview of the topics covered in detail throughout the rest of this series.</p><p>Especially if you&#39;re new to JavaScript, you should expect to spend quite a bit of time reviewing the concepts and code examples here multiple times. Any good foundation is laid brick by brick, so don&#39;t expect that you&#39;ll immediately understand it all the first pass through.</p><p>Your journey to deeply learn JavaScript starts here.</p><p><strong>Note:</strong> As I said in Chapter 1, you should definitely try all this code yourself as you read and work through this chapter. Be aware that some of the code here assumes capabilities introduced in the newest version of JavaScript at the time of this writing (commonly referred to as &quot;ES6&quot; for the 6th edition of ECMAScript -- the official name of the JS specification). If you happen to be using an older, pre-ES6 browser, the code may not work. A recent update of a modern browser (like Chrome, Firefox, or IE) should be used.</p><h2 id="values-types" tabindex="-1"><a class="header-anchor" href="#values-types" aria-hidden="true">#</a> Values &amp; Types</h2><p>As we asserted in Chapter 1, JavaScript has typed values, not typed variables. The following built-in types are available:</p><ul><li><code>string</code></li><li><code>number</code></li><li><code>boolean</code></li><li><code>null</code> and <code>undefined</code></li><li><code>object</code></li><li><code>symbol</code> (new to ES6)</li></ul><p>JavaScript provides a <code>typeof</code> operator that can examine a value and tell you what type it is:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a<span class="token punctuation">;</span>
<span class="token keyword">typeof</span> a<span class="token punctuation">;</span>				<span class="token comment">// &quot;undefined&quot;</span>

a <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> a<span class="token punctuation">;</span>				<span class="token comment">// &quot;string&quot;</span>

a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> a<span class="token punctuation">;</span>				<span class="token comment">// &quot;number&quot;</span>

a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> a<span class="token punctuation">;</span>				<span class="token comment">// &quot;boolean&quot;</span>

a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> a<span class="token punctuation">;</span>				<span class="token comment">// &quot;object&quot; -- weird, bug</span>

a <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> a<span class="token punctuation">;</span>				<span class="token comment">// &quot;undefined&quot;</span>

a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token string">&quot;c&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> a<span class="token punctuation">;</span>				<span class="token comment">// &quot;object&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>The return value from the <code>typeof</code> operator is always one of six (seven as of ES6! - the &quot;symbol&quot; type) string values. That is, <code>typeof &quot;abc&quot;</code> returns <code>&quot;string&quot;</code>, not <code>string</code>.</p><p>Notice how in this snippet the <code>a</code> variable holds every different type of value, and that despite appearances, <code>typeof a</code> is not asking for the &quot;type of <code>a</code>&quot;, but rather for the &quot;type of the value currently in <code>a</code>.&quot; Only values have types in JavaScript; variables are just simple containers for those values.</p><p><code>typeof null</code> is an interesting case, because it errantly returns <code>&quot;object&quot;</code>, when you&#39;d expect it to return <code>&quot;null&quot;</code>.</p><p><strong>Warning:</strong> This is a long-standing bug in JS, but one that is likely never going to be fixed. Too much code on the Web relies on the bug and thus fixing it would cause a lot more bugs!</p><p>Also, note <code>a = undefined</code>. We&#39;re explicitly setting <code>a</code> to the <code>undefined</code> value, but that is behaviorally no different from a variable that has no value set yet, like with the <code>var a;</code> line at the top of the snippet. A variable can get to this &quot;undefined&quot; value state in several different ways, including functions that return no values and usage of the <code>void</code> operator.</p><h3 id="objects" tabindex="-1"><a class="header-anchor" href="#objects" aria-hidden="true">#</a> Objects</h3><p>The <code>object</code> type refers to a compound value where you can set properties (named locations) that each hold their own values of any type. This is perhaps one of the most useful value types in all of JavaScript.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">,</span>
	<span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">,</span>
	<span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span>a<span class="token punctuation">;</span>		<span class="token comment">// &quot;hello world&quot;</span>
obj<span class="token punctuation">.</span>b<span class="token punctuation">;</span>		<span class="token comment">// 42</span>
obj<span class="token punctuation">.</span>c<span class="token punctuation">;</span>		<span class="token comment">// true</span>

obj<span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;hello world&quot;</span>
obj<span class="token punctuation">[</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// 42</span>
obj<span class="token punctuation">[</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>It may be helpful to think of this <code>obj</code> value visually:</p>`,21),i=["src"],l=n(`<p>Properties can either be accessed with <em>dot notation</em> (i.e., <code>obj.a</code>) or <em>bracket notation</em> (i.e., <code>obj[&quot;a&quot;]</code>). Dot notation is shorter and generally easier to read, and is thus preferred when possible.</p><p>Bracket notation is useful if you have a property name that has special characters in it, like <code>obj[&quot;hello world!&quot;]</code> -- such properties are often referred to as <em>keys</em> when accessed via bracket notation. The <code>[ ]</code> notation requires either a variable (explained next) or a <code>string</code> <em>literal</em> (which needs to be wrapped in <code>&quot; .. &quot;</code> or <code>&#39; .. &#39;</code>).</p><p>Of course, bracket notation is also useful if you want to access a property/key but the name is stored in another variable, such as:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">,</span>
	<span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">42</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>

obj<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">// &quot;hello world&quot;</span>
obj<span class="token punctuation">[</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">// 42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>Note:</strong> For more information on JavaScript <code>object</code>s, see the <em>this &amp; Object Prototypes</em> title of this series, specifically Chapter 3.</p><p>There are a couple of other value types that you will commonly interact with in JavaScript programs: <em>array</em> and <em>function</em>. But rather than being proper built-in types, these should be thought of more like subtypes -- specialized versions of the <code>object</code> type.</p><h4 id="arrays" tabindex="-1"><a class="header-anchor" href="#arrays" aria-hidden="true">#</a> Arrays</h4><p>An array is an <code>object</code> that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions. For example:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>
	<span class="token string">&quot;hello world&quot;</span><span class="token punctuation">,</span>
	<span class="token number">42</span><span class="token punctuation">,</span>
	<span class="token boolean">true</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">// &quot;hello world&quot;</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">// 42</span>
arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>			<span class="token comment">// true</span>
arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>		<span class="token comment">// 3</span>

<span class="token keyword">typeof</span> arr<span class="token punctuation">;</span>		<span class="token comment">// &quot;object&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>Note:</strong> Languages that start counting at zero, like JS does, use <code>0</code> as the index of the first element in the array.</p><p>It may be helpful to think of <code>arr</code> visually:</p>`,11),u=["src"],d=n(`<p>Because arrays are special objects (as <code>typeof</code> implies), they can also have properties, including the automatically updated <code>length</code> property.</p><p>You theoretically could use an array as a normal object with your own named properties, or you could use an <code>object</code> but only give it numeric properties (<code>0</code>, <code>1</code>, etc.) similar to an array. However, this would generally be considered improper usage of the respective types.</p><p>The best and most natural approach is to use arrays for numerically positioned values and use <code>object</code>s for named properties.</p><h4 id="functions" tabindex="-1"><a class="header-anchor" href="#functions" aria-hidden="true">#</a> Functions</h4><p>The other <code>object</code> subtype you&#39;ll use all over your JS programs is a function:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

foo<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">typeof</span> foo<span class="token punctuation">;</span>			<span class="token comment">// &quot;function&quot;</span>
<span class="token keyword">typeof</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// &quot;number&quot;</span>
<span class="token keyword">typeof</span> foo<span class="token punctuation">.</span>bar<span class="token punctuation">;</span>		<span class="token comment">// &quot;string&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Again, functions are a subtype of <code>objects</code> -- <code>typeof</code> returns <code>&quot;function&quot;</code>, which implies that a <code>function</code> is a main type -- and can thus have properties, but you typically will only use function object properties (like <code>foo.bar</code>) in limited cases.</p><p><strong>Note:</strong> For more information on JS values and their types, see the first two chapters of the <em>Types &amp; Grammar</em> title of this series.</p><h3 id="built-in-type-methods" tabindex="-1"><a class="header-anchor" href="#built-in-type-methods" aria-hidden="true">#</a> Built-In Type Methods</h3><p>The built-in types and subtypes we&#39;ve just discussed have behaviors exposed as properties and methods that are quite powerful and useful.</p><p>For example:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>				<span class="token comment">// 11</span>
a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// &quot;HELLO WORLD&quot;</span>
b<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// &quot;3.1416&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>The &quot;how&quot; behind being able to call <code>a.toUpperCase()</code> is more complicated than just that method existing on the value.</p><p>Briefly, there is a <code>String</code> (capital <code>S</code>) object wrapper form, typically called a &quot;native,&quot; that pairs with the primitive <code>string</code> type; it&#39;s this object wrapper that defines the <code>toUpperCase()</code> method on its prototype.</p><p>When you use a primitive value like <code>&quot;hello world&quot;</code> as an <code>object</code> by referencing a property or method (e.g., <code>a.toUpperCase()</code> in the previous snippet), JS automatically &quot;boxes&quot; the value to its object wrapper counterpart (hidden under the covers).</p><p>A <code>string</code> value can be wrapped by a <code>String</code> object, a <code>number</code> can be wrapped by a <code>Number</code> object, and a <code>boolean</code> can be wrapped by a <code>Boolean</code> object. For the most part, you don&#39;t need to worry about or directly use these object wrapper forms of the values -- prefer the primitive value forms in practically all cases and JavaScript will take care of the rest for you.</p><p><strong>Note:</strong> For more information on JS natives and &quot;boxing,&quot; see Chapter 3 of the <em>Types &amp; Grammar</em> title of this series. To better understand the prototype of an object, see Chapter 5 of the <em>this &amp; Object Prototypes</em> title of this series.</p><h3 id="comparing-values" tabindex="-1"><a class="header-anchor" href="#comparing-values" aria-hidden="true">#</a> Comparing Values</h3><p>There are two main types of value comparison that you will need to make in your JS programs: <em>equality</em> and <em>inequality</em>. The result of any comparison is a strictly <code>boolean</code> value (<code>true</code> or <code>false</code>), regardless of what value types are compared.</p><h4 id="coercion" tabindex="-1"><a class="header-anchor" href="#coercion" aria-hidden="true">#</a> Coercion</h4><p>We talked briefly about coercion in Chapter 1, but let&#39;s revisit it here.</p><p>Coercion comes in two forms in JavaScript: <em>explicit</em> and <em>implicit</em>. Explicit coercion is simply that you can see obviously from the code that a conversion from one type to another will occur, whereas implicit coercion is when the type conversion can happen as more of a non-obvious side effect of some other operation.</p><p>You&#39;ve probably heard sentiments like &quot;coercion is evil&quot; drawn from the fact that there are clearly places where coercion can produce some surprising results. Perhaps nothing evokes frustration from developers more than when the language surprises them.</p><p>Coercion is not evil, nor does it have to be surprising. In fact, the majority of cases you can construct with type coercion are quite sensible and understandable, and can even be used to <em>improve</em> the readability of your code. But we won&#39;t go much further into that debate -- Chapter 4 of the <em>Types &amp; Grammar</em> title of this series covers all sides.</p><p>Here&#39;s an example of <em>explicit</em> coercion:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;42&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span>				<span class="token comment">// &quot;42&quot;</span>
b<span class="token punctuation">;</span>				<span class="token comment">// 42 -- the number!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>And here&#39;s an example of <em>implicit</em> coercion:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;42&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;42&quot; implicitly coerced to 42 here</span>

a<span class="token punctuation">;</span>				<span class="token comment">// &quot;42&quot;</span>
b<span class="token punctuation">;</span>				<span class="token comment">// 42 -- the number!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="truthy-falsy" tabindex="-1"><a class="header-anchor" href="#truthy-falsy" aria-hidden="true">#</a> Truthy &amp; Falsy</h4><p>In Chapter 1, we briefly mentioned the &quot;truthy&quot; and &quot;falsy&quot; nature of values: when a non-<code>boolean</code> value is coerced to a <code>boolean</code>, does it become <code>true</code> or <code>false</code>, respectively?</p><p>The specific list of &quot;falsy&quot; values in JavaScript is as follows:</p><ul><li><code>&quot;&quot;</code> (empty string)</li><li><code>0</code>, <code>-0</code>, <code>NaN</code> (invalid <code>number</code>)</li><li><code>null</code>, <code>undefined</code></li><li><code>false</code></li></ul><p>Any value that&#39;s not on this &quot;falsy&quot; list is &quot;truthy.&quot; Here are some examples of those:</p><ul><li><code>&quot;hello&quot;</code></li><li><code>42</code></li><li><code>true</code></li><li><code>[ ]</code>, <code>[ 1, &quot;2&quot;, 3 ]</code> (arrays)</li><li><code>{ }</code>, <code>{ a: 42 }</code> (objects)</li><li><code>function foo() { .. }</code> (functions)</li></ul><p>It&#39;s important to remember that a non-<code>boolean</code> value only follows this &quot;truthy&quot;/&quot;falsy&quot; coercion if it&#39;s actually coerced to a <code>boolean</code>. It&#39;s not all that difficult to confuse yourself with a situation that seems like it&#39;s coercing a value to a <code>boolean</code> when it&#39;s not.</p><h4 id="equality" tabindex="-1"><a class="header-anchor" href="#equality" aria-hidden="true">#</a> Equality</h4><p>There are four equality operators: <code>==</code>, <code>===</code>, <code>!=</code>, and <code>!==</code>. The <code>!</code> forms are of course the symmetric &quot;not equal&quot; versions of their counterparts; <em>non-equality</em> should not be confused with <em>inequality</em>.</p><p>The difference between <code>==</code> and <code>===</code> is usually characterized that <code>==</code> checks for value equality and <code>===</code> checks for both value and type equality. However, this is inaccurate. The proper way to characterize them is that <code>==</code> checks for value equality with coercion allowed, and <code>===</code> checks for value equality without allowing coercion; <code>===</code> is often called &quot;strict equality&quot; for this reason.</p><p>Consider the implicit coercion that&#39;s allowed by the <code>==</code> loose-equality comparison and not allowed with the <code>===</code> strict-equality:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;42&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

a <span class="token operator">==</span> b<span class="token punctuation">;</span>			<span class="token comment">// true</span>
a <span class="token operator">===</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>In the <code>a == b</code> comparison, JS notices that the types do not match, so it goes through an ordered series of steps to coerce one or both values to a different type until the types match, where then a simple value equality can be checked.</p><p>If you think about it, there&#39;s two possible ways <code>a == b</code> could give <code>true</code> via coercion. Either the comparison could end up as <code>42 == 42</code> or it could be <code>&quot;42&quot; == &quot;42&quot;</code>. So which is it?</p><p>The answer: <code>&quot;42&quot;</code> becomes <code>42</code>, to make the comparison <code>42 == 42</code>. In such a simple example, it doesn&#39;t really seem to matter which way that process goes, as the end result is the same. There are more complex cases where it matters not just what the end result of the comparison is, but <em>how</em> you get there.</p><p>The <code>a === b</code> produces <code>false</code>, because the coercion is not allowed, so the simple value comparison obviously fails. Many developers feel that <code>===</code> is more predictable, so they advocate always using that form and staying away from <code>==</code>. I think this view is very shortsighted. I believe <code>==</code> is a powerful tool that helps your program, <em>if you take the time to learn how it works.</em></p><p>We&#39;re not going to cover all the nitty-gritty details of how the coercion in <code>==</code> comparisons works here. Much of it is pretty sensible, but there are some important corner cases to be careful of. You can read section 11.9.3 of the ES5 specification (http://www.ecma-international.org/ecma-262/5.1/) to see the exact rules, and you&#39;ll be surprised at just how straightforward this mechanism is, compared to all the negative hype surrounding it.</p><p>To boil down a whole lot of details to a few simple takeaways, and help you know whether to use <code>==</code> or <code>===</code> in various situations, here are my simple rules:</p><ul><li>If either value (aka side) in a comparison could be the <code>true</code> or <code>false</code> value, avoid <code>==</code> and use <code>===</code>.</li><li>If either value in a comparison could be one of these specific values (<code>0</code>, <code>&quot;&quot;</code>, or <code>[]</code> -- empty array), avoid <code>==</code> and use <code>===</code>.</li><li>In <em>all</em> other cases, you&#39;re safe to use <code>==</code>. Not only is it safe, but in many cases it simplifies your code in a way that improves readability.</li></ul><p>What these rules boil down to is requiring you to think critically about your code and about what kinds of values can come through variables that get compared for equality. If you can be certain about the values, and <code>==</code> is safe, use it! If you can&#39;t be certain about the values, use <code>===</code>. It&#39;s that simple.</p><p>The <code>!=</code> non-equality form pairs with <code>==</code>, and the <code>!==</code> form pairs with <code>===</code>. All the rules and observations we just discussed hold symmetrically for these non-equality comparisons.</p><p>You should take special note of the <code>==</code> and <code>===</code> comparison rules if you&#39;re comparing two non-primitive values, like <code>object</code>s (including <code>function</code> and <code>array</code>). Because those values are actually held by reference, both <code>==</code> and <code>===</code> comparisons will simply check whether the references match, not anything about the underlying values.</p><p>For example, <code>array</code>s are by default coerced to <code>string</code>s by simply joining all the values with commas (<code>,</code>) in between. You might think that two <code>array</code>s with the same contents would be <code>==</code> equal, but they&#39;re not:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">&quot;1,2,3&quot;</span><span class="token punctuation">;</span>

a <span class="token operator">==</span> c<span class="token punctuation">;</span>		<span class="token comment">// true</span>
b <span class="token operator">==</span> c<span class="token punctuation">;</span>		<span class="token comment">// true</span>
a <span class="token operator">==</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>Note:</strong> For more information about the <code>==</code> equality comparison rules, see the ES5 specification (section 11.9.3) and also consult Chapter 4 of the <em>Types &amp; Grammar</em> title of this series; see Chapter 2 for more information about values versus references.</p><h4 id="inequality" tabindex="-1"><a class="header-anchor" href="#inequality" aria-hidden="true">#</a> Inequality</h4><p>The <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators are used for inequality, referred to in the specification as &quot;relational comparison.&quot; Typically they will be used with ordinally comparable values like <code>number</code>s. It&#39;s easy to understand that <code>3 &lt; 4</code>.</p><p>But JavaScript <code>string</code> values can also be compared for inequality, using typical alphabetic rules (<code>&quot;bar&quot; &lt; &quot;foo&quot;</code>).</p><p>What about coercion? Similar rules as <code>==</code> comparison (though not exactly identical!) apply to the inequality operators. Notably, there are no &quot;strict inequality&quot; operators that would disallow coercion the same way <code>===</code> &quot;strict equality&quot; does.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;42&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">&quot;43&quot;</span><span class="token punctuation">;</span>

a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span>		<span class="token comment">// true</span>
b <span class="token operator">&lt;</span> c<span class="token punctuation">;</span>		<span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>What happens here? In section 11.8.5 of the ES5 specification, it says that if both values in the <code>&lt;</code> comparison are <code>string</code>s, as it is with <code>b &lt; c</code>, the comparison is made lexicographically (aka alphabetically like a dictionary). But if one or both is not a <code>string</code>, as it is with <code>a &lt; b</code>, then both values are coerced to be <code>number</code>s, and a typical numeric comparison occurs.</p><p>The biggest gotcha you may run into here with comparisons between potentially different value types -- remember, there are no &quot;strict inequality&quot; forms to use -- is when one of the values cannot be made into a valid number, such as:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span>
a <span class="token operator">&gt;</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span>
a <span class="token operator">==</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Wait, how can all three of those comparisons be <code>false</code>? Because the <code>b</code> value is being coerced to the &quot;invalid number value&quot; <code>NaN</code> in the <code>&lt;</code> and <code>&gt;</code> comparisons, and the specification says that <code>NaN</code> is neither greater-than nor less-than any other value.</p><p>The <code>==</code> comparison fails for a different reason. <code>a == b</code> could fail if it&#39;s interpreted either as <code>42 == NaN</code> or <code>&quot;42&quot; == &quot;foo&quot;</code> -- as we explained earlier, the former is the case.</p><p><strong>Note:</strong> For more information about the inequality comparison rules, see section 11.8.5 of the ES5 specification and also consult Chapter 4 of the <em>Types &amp; Grammar</em> title of this series.</p><h2 id="variables" tabindex="-1"><a class="header-anchor" href="#variables" aria-hidden="true">#</a> Variables</h2><p>In JavaScript, variable names (including function names) must be valid <em>identifiers</em>. The strict and complete rules for valid characters in identifiers are a little complex when you consider nontraditional characters such as Unicode. If you only consider typical ASCII alphanumeric characters though, the rules are simple.</p><p>An identifier must start with <code>a</code>-<code>z</code>, <code>A</code>-<code>Z</code>, <code>$</code>, or <code>_</code>. It can then contain any of those characters plus the numerals <code>0</code>-<code>9</code>.</p><p>Generally, the same rules apply to a property name as to a variable identifier. However, certain words cannot be used as variables, but are OK as property names. These words are called &quot;reserved words,&quot; and include the JS keywords (<code>for</code>, <code>in</code>, <code>if</code>, etc.) as well as <code>null</code>, <code>true</code>, and <code>false</code>.</p><p><strong>Note:</strong> For more information about reserved words, see Appendix A of the <em>Types &amp; Grammar</em> title of this series.</p><h3 id="function-scopes" tabindex="-1"><a class="header-anchor" href="#function-scopes" aria-hidden="true">#</a> Function Scopes</h3><p>You use the <code>var</code> keyword to declare a variable that will belong to the current function scope, or the global scope if at the top level outside of any function.</p><h4 id="hoisting" tabindex="-1"><a class="header-anchor" href="#hoisting" aria-hidden="true">#</a> Hoisting</h4><p>Wherever a <code>var</code> appears inside a scope, that declaration is taken to belong to the entire scope and accessible everywhere throughout.</p><p>Metaphorically, this behavior is called <em>hoisting</em>, when a <code>var</code> declaration is conceptually &quot;moved&quot; to the top of its enclosing scope. Technically, this process is more accurately explained by how code is compiled, but we can skip over those details for now.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// works because \`foo()\`</span>
						<span class="token comment">// declaration is &quot;hoisted&quot;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 3</span>

	<span class="token keyword">var</span> a<span class="token punctuation">;</span>				<span class="token comment">// declaration is &quot;hoisted&quot;</span>
						<span class="token comment">// to the top of \`foo()\`</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>Warning:</strong> It&#39;s not common or a good idea to rely on variable <em>hoisting</em> to use a variable earlier in its scope than its <code>var</code> declaration appears; it can be quite confusing. It&#39;s much more common and accepted to use <em>hoisted</em> function declarations, as we do with the <code>foo()</code> call appearing before its formal declaration.</p><h4 id="nested-scopes" tabindex="-1"><a class="header-anchor" href="#nested-scopes" aria-hidden="true">#</a> Nested Scopes</h4><p>When you declare a variable, it is available anywhere in that scope, as well as any lower/inner scopes. For example:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

		<span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 1 2 3</span>
		<span class="token punctuation">}</span>

		<span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 1 2</span>
	<span class="token punctuation">}</span>

	<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 1</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>Notice that <code>c</code> is not available inside of <code>bar()</code>, because it&#39;s declared only inside the inner <code>baz()</code> scope, and that <code>b</code> is not available to <code>foo()</code> for the same reason.</p><p>If you try to access a variable&#39;s value in a scope where it&#39;s not available, you&#39;ll get a <code>ReferenceError</code> thrown. If you try to set a variable that hasn&#39;t been declared, you&#39;ll either end up creating a variable in the top-level global scope (bad!) or getting an error, depending on &quot;strict mode&quot; (see &quot;Strict Mode&quot;). Let&#39;s take a look:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>	<span class="token comment">// \`a\` not formally declared</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span>			<span class="token comment">// 1 -- oops, auto global variable :(</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>This is a very bad practice. Don&#39;t do it! Always formally declare your variables.</p><p>In addition to creating declarations for variables at the function level, ES6 <em>lets</em> you declare variables to belong to individual blocks (pairs of <code>{ .. }</code>), using the <code>let</code> keyword. Besides some nuanced details, the scoping rules will behave roughly the same as we just saw with functions:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

		<span class="token keyword">while</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">let</span> c <span class="token operator">=</span> b <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
			b<span class="token operator">++</span><span class="token punctuation">;</span>

			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token operator">+</span> c <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 5 7 9</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>Because of using <code>let</code> instead of <code>var</code>, <code>b</code> will belong only to the <code>if</code> statement and thus not to the whole <code>foo()</code> function&#39;s scope. Similarly, <code>c</code> belongs only to the <code>while</code> loop. Block scoping is very useful for managing your variable scopes in a more fine-grained fashion, which can make your code much easier to maintain over time.</p><p><strong>Note:</strong> For more information about scope, see the <em>Scope &amp; Closures</em> title of this series. See the <em>ES6 &amp; Beyond</em> title of this series for more information about <code>let</code> block scoping.</p><h2 id="conditionals" tabindex="-1"><a class="header-anchor" href="#conditionals" aria-hidden="true">#</a> Conditionals</h2><p>In addition to the <code>if</code> statement we introduced briefly in Chapter 1, JavaScript provides a few other conditionals mechanisms that we should take a look at.</p><p>Sometimes you may find yourself writing a series of <code>if..else..if</code> statements like this:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// do something</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// do another thing</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// do yet another thing</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
	<span class="token comment">// fallback to here</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>This structure works, but it&#39;s a little verbose because you need to specify the <code>a</code> test for each case. Here&#39;s another option, the <code>switch</code> statement:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
		<span class="token comment">// do something</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">case</span> <span class="token number">10</span><span class="token operator">:</span>
		<span class="token comment">// do another thing</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">case</span> <span class="token number">42</span><span class="token operator">:</span>
		<span class="token comment">// do yet another thing</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">default</span><span class="token operator">:</span>
		<span class="token comment">// fallback to here</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>The <code>break</code> is important if you want only the statement(s) in one <code>case</code> to run. If you omit <code>break</code> from a <code>case</code>, and that <code>case</code> matches or runs, execution will continue with the next <code>case</code>&#39;s statements regardless of that <code>case</code> matching. This so called &quot;fall through&quot; is sometimes useful/desired:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
	<span class="token keyword">case</span> <span class="token number">10</span><span class="token operator">:</span>
		<span class="token comment">// some cool stuff</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">case</span> <span class="token number">42</span><span class="token operator">:</span>
		<span class="token comment">// other stuff</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">default</span><span class="token operator">:</span>
		<span class="token comment">// fallback</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Here, if <code>a</code> is either <code>2</code> or <code>10</code>, it will execute the &quot;some cool stuff&quot; code statements.</p><p>Another form of conditional in JavaScript is the &quot;conditional operator,&quot; often called the &quot;ternary operator.&quot; It&#39;s like a more concise form of a single <code>if..else</code> statement, such as:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> <span class="token number">41</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot;hello&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// similar to:</span>

<span class="token comment">// if (a &gt; 41) {</span>
<span class="token comment">//    b = &quot;hello&quot;;</span>
<span class="token comment">// }</span>
<span class="token comment">// else {</span>
<span class="token comment">//    b = &quot;world&quot;;</span>
<span class="token comment">// }</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>If the test expression (<code>a &gt; 41</code> here) evaluates as <code>true</code>, the first clause (<code>&quot;hello&quot;</code>) results, otherwise the second clause (<code>&quot;world&quot;</code>) results, and whatever the result is then gets assigned to <code>b</code>.</p><p>The conditional operator doesn&#39;t have to be used in an assignment, but that&#39;s definitely the most common usage.</p><p><strong>Note:</strong> For more information about testing conditions and other patterns for <code>switch</code> and <code>? :</code>, see the <em>Types &amp; Grammar</em> title of this series.</p><h2 id="strict-mode" tabindex="-1"><a class="header-anchor" href="#strict-mode" aria-hidden="true">#</a> Strict Mode</h2><p>ES5 added a &quot;strict mode&quot; to the language, which tightens the rules for certain behaviors. Generally, these restrictions are seen as keeping the code to a safer and more appropriate set of guidelines. Also, adhering to strict mode makes your code generally more optimizable by the engine. Strict mode is a big win for code, and you should use it for all your programs.</p><p>You can opt in to strict mode for an individual function, or an entire file, depending on where you put the strict mode pragma:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

	<span class="token comment">// this code is strict mode</span>

	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// this code is strict mode</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// this code is not strict mode</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Compare that to:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// this code is strict mode</span>

	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// this code is strict mode</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// this code is strict mode</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>One key difference (improvement!) with strict mode is disallowing the implicit auto-global variable declaration from omitting the <code>var</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>	<span class="token comment">// turn on strict mode</span>
	a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>			<span class="token comment">// \`var\` missing, ReferenceError</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>If you turn on strict mode in your code, and you get errors, or code starts behaving buggy, your temptation might be to avoid strict mode. But that instinct would be a bad idea to indulge. If strict mode causes issues in your program, almost certainly it&#39;s a sign that you have things in your program you should fix.</p><p>Not only will strict mode keep your code to a safer path, and not only will it make your code more optimizable, but it also represents the future direction of the language. It&#39;d be easier on you to get used to strict mode now than to keep putting it off -- it&#39;ll only get harder to convert later!</p><p><strong>Note:</strong> For more information about strict mode, see the Chapter 5 of the <em>Types &amp; Grammar</em> title of this series.</p><h2 id="functions-as-values" tabindex="-1"><a class="header-anchor" href="#functions-as-values" aria-hidden="true">#</a> Functions As Values</h2><p>So far, we&#39;ve discussed functions as the primary mechanism of <em>scope</em> in JavaScript. You recall typical <code>function</code> declaration syntax as follows:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ..</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Though it may not seem obvious from that syntax, <code>foo</code> is basically just a variable in the outer enclosing scope that&#39;s given a reference to the <code>function</code> being declared. That is, the <code>function</code> itself is a value, just like <code>42</code> or <code>[1,2,3]</code> would be.</p><p>This may sound like a strange concept at first, so take a moment to ponder it. Not only can you pass a value (argument) <em>to</em> a function, but <em>a function itself can be a value</em> that&#39;s assigned to variables, or passed to or returned from other functions.</p><p>As such, a function value should be thought of as an expression, much like any other value or expression.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>The first function expression assigned to the <code>foo</code> variable is called <em>anonymous</em> because it has no <code>name</code>.</p><p>The second function expression is <em>named</em> (<code>bar</code>), even as a reference to it is also assigned to the <code>x</code> variable. <em>Named function expressions</em> are generally more preferable, though <em>anonymous function expressions</em> are still extremely common.</p><p>For more information, see the <em>Scope &amp; Closures</em> title of this series.</p><h3 id="immediately-invoked-function-expressions-iifes" tabindex="-1"><a class="header-anchor" href="#immediately-invoked-function-expressions-iifes" aria-hidden="true">#</a> Immediately Invoked Function Expressions (IIFEs)</h3><p>In the previous snippet, neither of the function expressions are executed -- we could if we had included <code>foo()</code> or <code>x()</code>, for instance.</p><p>There&#39;s another way to execute a function expression, which is typically referred to as an <em>immediately invoked function expression</em> (IIFE):</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Hello!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// &quot;Hello!&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>The outer <code>( .. )</code> that surrounds the <code>(function IIFE(){ .. })</code> function expression is just a nuance of JS grammar needed to prevent it from being treated as a normal function declaration.</p><p>The final <code>()</code> on the end of the expression -- the <code>})();</code> line -- is what actually executes the function expression referenced immediately before it.</p><p>That may seem strange, but it&#39;s not as foreign as first glance. Consider the similarities between <code>foo</code> and <code>IIFE</code> here:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token comment">// \`foo\` function reference expression,</span>
<span class="token comment">// then \`()\` executes it</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// \`IIFE\` function expression,</span>
<span class="token comment">// then \`()\` executes it</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>As you can see, listing the <code>(function IIFE(){ .. })</code> before its executing <code>()</code> is essentially the same as including <code>foo</code> before its executing <code>()</code>; in both cases, the function reference is executed with <code>()</code> immediately after it.</p><p>Because an IIFE is just a function, and functions create variable <em>scope</em>, using an IIFE in this fashion is often used to declare variables that won&#39;t affect the surrounding code outside the IIFE:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 10</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>IIFEs can also have return values:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

x<span class="token punctuation">;</span>	<span class="token comment">// 42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The <code>42</code> value gets <code>return</code>ed from the <code>IIFE</code>-named function being executed, and is then assigned to <code>x</code>.</p><h3 id="closure" tabindex="-1"><a class="header-anchor" href="#closure" aria-hidden="true">#</a> Closure</h3><p><em>Closure</em> is one of the most important, and often least understood, concepts in JavaScript. I won&#39;t cover it in deep detail here, and instead refer you to the <em>Scope &amp; Closures</em> title of this series. But I want to say a few things about it so you understand the general concept. It will be one of the most important techniques in your JS skillset.</p><p>You can think of closure as a way to &quot;remember&quot; and continue to access a function&#39;s scope (its variables) even once the function has finished running.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// parameter \`x\` is an inner variable</span>

	<span class="token comment">// inner function \`add()\` uses \`x\`, so</span>
	<span class="token comment">// it has a &quot;closure&quot; over it</span>
	<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> y <span class="token operator">+</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> add<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>The reference to the inner <code>add(..)</code> function that gets returned with each call to the outer <code>makeAdder(..)</code> is able to remember whatever <code>x</code> value was passed in to <code>makeAdder(..)</code>. Now, let&#39;s use <code>makeAdder(..)</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// \`plusOne\` gets a reference to the inner \`add(..)\`</span>
<span class="token comment">// function with closure over the \`x\` parameter of</span>
<span class="token comment">// the outer \`makeAdder(..)\`</span>
<span class="token keyword">var</span> plusOne <span class="token operator">=</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// \`plusTen\` gets a reference to the inner \`add(..)\`</span>
<span class="token comment">// function with closure over the \`x\` parameter of</span>
<span class="token comment">// the outer \`makeAdder(..)\`</span>
<span class="token keyword">var</span> plusTen <span class="token operator">=</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">plusOne</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 4  &lt;-- 1 + 3</span>
<span class="token function">plusOne</span><span class="token punctuation">(</span> <span class="token number">41</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 42 &lt;-- 1 + 41</span>

<span class="token function">plusTen</span><span class="token punctuation">(</span> <span class="token number">13</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 23 &lt;-- 10 + 13</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>More on how this code works:</p><ol><li>When we call <code>makeAdder(1)</code>, we get back a reference to its inner <code>add(..)</code> that remembers <code>x</code> as <code>1</code>. We call this function reference <code>plusOne(..)</code>.</li><li>When we call <code>makeAdder(10)</code>, we get back another reference to its inner <code>add(..)</code> that remembers <code>x</code> as <code>10</code>. We call this function reference <code>plusTen(..)</code>.</li><li>When we call <code>plusOne(3)</code>, it adds <code>3</code> (its inner <code>y</code>) to the <code>1</code> (remembered by <code>x</code>), and we get <code>4</code> as the result.</li><li>When we call <code>plusTen(13)</code>, it adds <code>13</code> (its inner <code>y</code>) to the <code>10</code> (remembered by <code>x</code>), and we get <code>23</code> as the result.</li></ol><p>Don&#39;t worry if this seems strange and confusing at first -- it can be! It&#39;ll take lots of practice to understand it fully.</p><p>But trust me, once you do, it&#39;s one of the most powerful and useful techniques in all of programming. It&#39;s definitely worth the effort to let your brain simmer on closures for a bit. In the next section, we&#39;ll get a little more practice with closure.</p><h4 id="modules" tabindex="-1"><a class="header-anchor" href="#modules" aria-hidden="true">#</a> Modules</h4><p>The most common usage of closure in JavaScript is the module pattern. Modules let you define private implementation details (variables, functions) that are hidden from the outside world, as well as a public API that <em>is</em> accessible from the outside.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">var</span> username<span class="token punctuation">,</span> password<span class="token punctuation">;</span>

	<span class="token keyword">function</span> <span class="token function">doLogin</span><span class="token punctuation">(</span><span class="token parameter">user<span class="token punctuation">,</span>pw</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		username <span class="token operator">=</span> user<span class="token punctuation">;</span>
		password <span class="token operator">=</span> pw<span class="token punctuation">;</span>

		<span class="token comment">// do the rest of the login work</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> publicAPI <span class="token operator">=</span> <span class="token punctuation">{</span>
		<span class="token literal-property property">login</span><span class="token operator">:</span> doLogin
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> publicAPI<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// create a \`User\` module instance</span>
<span class="token keyword">var</span> fred <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fred<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span> <span class="token string">&quot;fred&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;12Battery34!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>The <code>User()</code> function serves as an outer scope that holds the variables <code>username</code> and <code>password</code>, as well as the inner <code>doLogin()</code> function; these are all private inner details of this <code>User</code> module that cannot be accessed from the outside world.</p><p><strong>Warning:</strong> We are not calling <code>new User()</code> here, on purpose, despite the fact that probably seems more common to most readers. <code>User()</code> is just a function, not a class to be instantiated, so it&#39;s just called normally. Using <code>new</code> would be inappropriate and actually waste resources.</p><p>Executing <code>User()</code> creates an <em>instance</em> of the <code>User</code> module -- a whole new scope is created, and thus a whole new copy of each of these inner variables/functions. We assign this instance to <code>fred</code>. If we run <code>User()</code> again, we&#39;d get a new instance entirely separate from <code>fred</code>.</p><p>The inner <code>doLogin()</code> function has a closure over <code>username</code> and <code>password</code>, meaning it will retain its access to them even after the <code>User()</code> function finishes running.</p><p><code>publicAPI</code> is an object with one property/method on it, <code>login</code>, which is a reference to the inner <code>doLogin()</code> function. When we return <code>publicAPI</code> from <code>User()</code>, it becomes the instance we call <code>fred</code>.</p><p>At this point, the outer <code>User()</code> function has finished executing. Normally, you&#39;d think the inner variables like <code>username</code> and <code>password</code> have gone away. But here they have not, because there&#39;s a closure in the <code>login()</code> function keeping them alive.</p><p>That&#39;s why we can call <code>fred.login(..)</code> -- the same as calling the inner <code>doLogin(..)</code> -- and it can still access <code>username</code> and <code>password</code> inner variables.</p><p>There&#39;s a good chance that with just this brief glimpse at closure and the module pattern, some of it is still a bit confusing. That&#39;s OK! It takes some work to wrap your brain around it.</p><p>From here, go read the <em>Scope &amp; Closures</em> title of this series for a much more in-depth exploration.</p><h2 id="this-identifier" tabindex="-1"><a class="header-anchor" href="#this-identifier" aria-hidden="true">#</a> <code>this</code> Identifier</h2><p>Another very commonly misunderstood concept in JavaScript is the <code>this</code> identifier. Again, there&#39;s a couple of chapters on it in the <em>this &amp; Object Prototypes</em> title of this series, so here we&#39;ll just briefly introduce the concept.</p><p>While it may often seem that <code>this</code> is related to &quot;object-oriented patterns,&quot; in JS <code>this</code> is a different mechanism.</p><p>If a function has a <code>this</code> reference inside it, that <code>this</code> reference usually points to an <code>object</code>. But which <code>object</code> it points to depends on how the function was called.</p><p>It&#39;s important to realize that <code>this</code> <em>does not</em> refer to the function itself, as is the most common misconception.</p><p>Here&#39;s a quick illustration:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>bar <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token string">&quot;global&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">&quot;obj1&quot;</span><span class="token punctuation">,</span>
	<span class="token literal-property property">foo</span><span class="token operator">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token string">&quot;obj2&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// --------</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// &quot;global&quot;</span>
obj1<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// &quot;obj1&quot;</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj2 <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// &quot;obj2&quot;</span>
<span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>There are four rules for how <code>this</code> gets set, and they&#39;re shown in those last four lines of that snippet.</p><ol><li><code>foo()</code> ends up setting <code>this</code> to the global object in non-strict mode -- in strict mode, <code>this</code> would be <code>undefined</code> and you&#39;d get an error in accessing the <code>bar</code> property -- so <code>&quot;global&quot;</code> is the value found for <code>this.bar</code>.</li><li><code>obj1.foo()</code> sets <code>this</code> to the <code>obj1</code> object.</li><li><code>foo.call(obj2)</code> sets <code>this</code> to the <code>obj2</code> object.</li><li><code>new foo()</code> sets <code>this</code> to a brand new empty object.</li></ol><p>Bottom line: to understand what <code>this</code> points to, you have to examine how the function in question was called. It will be one of those four ways just shown, and that will then answer what <code>this</code> is.</p><p><strong>Note:</strong> For more information about <code>this</code>, see Chapters 1 and 2 of the <em>this &amp; Object Prototypes</em> title of this series.</p><h2 id="prototypes" tabindex="-1"><a class="header-anchor" href="#prototypes" aria-hidden="true">#</a> Prototypes</h2><p>The prototype mechanism in JavaScript is quite complicated. We will only glance at it here. You will want to spend plenty of time reviewing Chapters 4-6 of the <em>this &amp; Object Prototypes</em> title of this series for all the details.</p><p>When you reference a property on an object, if that property doesn&#39;t exist, JavaScript will automatically use that object&#39;s internal prototype reference to find another object to look for the property on. You could think of this almost as a fallback if the property is missing.</p><p>The internal prototype reference linkage from one object to its fallback happens at the time the object is created. The simplest way to illustrate it is with a built-in utility called <code>Object.create(..)</code>.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">42</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// create \`bar\` and link it to \`foo\`</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> foo <span class="token punctuation">)</span><span class="token punctuation">;</span>

bar<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>

bar<span class="token punctuation">.</span>b<span class="token punctuation">;</span>		<span class="token comment">// &quot;hello world&quot;</span>
bar<span class="token punctuation">.</span>a<span class="token punctuation">;</span>		<span class="token comment">// 42 &lt;-- delegated to \`foo\`</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>It may help to visualize the <code>foo</code> and <code>bar</code> objects and their relationship:</p>`,181),m=["src"],b=n(`<p>The <code>a</code> property doesn&#39;t actually exist on the <code>bar</code> object, but because <code>bar</code> is prototype-linked to <code>foo</code>, JavaScript automatically falls back to looking for <code>a</code> on the <code>foo</code> object, where it&#39;s found.</p><p>This linkage may seem like a strange feature of the language. The most common way this feature is used -- and I would argue, abused -- is to try to emulate/fake a &quot;class&quot; mechanism with &quot;inheritance.&quot;</p><p>But a more natural way of applying prototypes is a pattern called &quot;behavior delegation,&quot; where you intentionally design your linked objects to be able to <em>delegate</em> from one to the other for parts of the needed behavior.</p><p><strong>Note:</strong> For more information about prototypes and behavior delegation, see Chapters 4-6 of the <em>this &amp; Object Prototypes</em> title of this series.</p><h2 id="old-new" tabindex="-1"><a class="header-anchor" href="#old-new" aria-hidden="true">#</a> Old &amp; New</h2><p>Some of the JS features we&#39;ve already covered, and certainly many of the features covered in the rest of this series, are newer additions and will not necessarily be available in older browsers. In fact, some of the newest features in the specification aren&#39;t even implemented in any stable browsers yet.</p><p>So, what do you do with the new stuff? Do you just have to wait around for years or decades for all the old browsers to fade into obscurity?</p><p>That&#39;s how many people think about the situation, but it&#39;s really not a healthy approach to JS.</p><p>There are two main techniques you can use to &quot;bring&quot; the newer JavaScript stuff to the older browsers: polyfilling and transpiling.</p><h3 id="polyfilling" tabindex="-1"><a class="header-anchor" href="#polyfilling" aria-hidden="true">#</a> Polyfilling</h3><p>The word &quot;polyfill&quot; is an invented term (by Remy Sharp) (https://remysharp.com/2010/10/08/what-is-a-polyfill) used to refer to taking the definition of a newer feature and producing a piece of code that&#39;s equivalent to the behavior, but is able to run in older JS environments.</p><p>For example, ES6 defines a utility called <code>Number.isNaN(..)</code> to provide an accurate non-buggy check for <code>NaN</code> values, deprecating the original <code>isNaN(..)</code> utility. But it&#39;s easy to polyfill that utility so that you can start using it in your code regardless of whether the end user is in an ES6 browser or not.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span>isNaN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token function-variable function">isNaN</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> x <span class="token operator">!==</span> x<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The <code>if</code> statement guards against applying the polyfill definition in ES6 browsers where it will already exist. If it&#39;s not already present, we define <code>Number.isNaN(..)</code>.</p><p><strong>Note:</strong> The check we do here takes advantage of a quirk with <code>NaN</code> values, which is that they&#39;re the only value in the whole language that is not equal to itself. So the <code>NaN</code> value is the only one that would make <code>x !== x</code> be <code>true</code>.</p><p>Not all new features are fully polyfillable. Sometimes most of the behavior can be polyfilled, but there are still small deviations. You should be really, really careful in implementing a polyfill yourself, to make sure you are adhering to the specification as strictly as possible.</p><p>Or better yet, use an already vetted set of polyfills that you can trust, such as those provided by ES5-Shim (https://github.com/es-shims/es5-shim) and ES6-Shim (https://github.com/es-shims/es6-shim).</p><h3 id="transpiling" tabindex="-1"><a class="header-anchor" href="#transpiling" aria-hidden="true">#</a> Transpiling</h3><p>There&#39;s no way to polyfill new syntax that has been added to the language. The new syntax would throw an error in the old JS engine as unrecognized/invalid.</p><p>So the better option is to use a tool that converts your newer code into older code equivalents. This process is commonly called &quot;transpiling,&quot; a term for transforming + compiling.</p><p>Essentially, your source code is authored in the new syntax form, but what you deploy to the browser is the transpiled code in old syntax form. You typically insert the transpiler into your build process, similar to your code linter or your minifier.</p><p>You might wonder why you&#39;d go to the trouble to write new syntax only to have it transpiled away to older code -- why not just write the older code directly?</p><p>There are several important reasons you should care about transpiling:</p><ul><li>The new syntax added to the language is designed to make your code more readable and maintainable. The older equivalents are often much more convoluted. You should prefer writing newer and cleaner syntax, not only for yourself but for all other members of the development team.</li><li>If you transpile only for older browsers, but serve the new syntax to the newest browsers, you get to take advantage of browser performance optimizations with the new syntax. This also lets browser makers have more real-world code to test their implementations and optimizations on.</li><li>Using the new syntax earlier allows it to be tested more robustly in the real world, which provides earlier feedback to the JavaScript committee (TC39). If issues are found early enough, they can be changed/fixed before those language design mistakes become permanent.</li></ul><p>Here&#39;s a quick example of transpiling. ES6 adds a feature called &quot;default parameter values.&quot; It looks like this:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a <span class="token operator">=</span> <span class="token number">2</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 2</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Simple, right? Helpful, too! But it&#39;s new syntax that&#39;s invalid in pre-ES6 engines. So what will a transpiler do with that code to make it run in older environments?</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>As you can see, it checks to see if the <code>arguments[0]</code> value is <code>void 0</code> (aka <code>undefined</code>), and if so provides the <code>2</code> default value; otherwise, it assigns whatever was passed.</p><p>In addition to being able to now use the nicer syntax even in older browsers, looking at the transpiled code actually explains the intended behavior more clearly.</p><p>You may not have realized just from looking at the ES6 version that <code>undefined</code> is the only value that can&#39;t get explicitly passed in for a default-value parameter, but the transpiled code makes that much more clear.</p><p>The last important detail to emphasize about transpilers is that they should now be thought of as a standard part of the JS development ecosystem and process. JS is going to continue to evolve, much more quickly than before, so every few months new syntax and new features will be added.</p><p>If you use a transpiler by default, you&#39;ll always be able to make that switch to newer syntax whenever you find it useful, rather than always waiting for years for today&#39;s browsers to phase out.</p><p>There are quite a few great transpilers for you to choose from. Here are some good options at the time of this writing:</p><ul><li>Babel (https://babeljs.io) (formerly 6to5): Transpiles ES6+ into ES5</li><li>Traceur (https://github.com/google/traceur-compiler): Transpiles ES6, ES7, and beyond into ES5</li></ul><h2 id="non-javascript" tabindex="-1"><a class="header-anchor" href="#non-javascript" aria-hidden="true">#</a> Non-JavaScript</h2><p>So far, the only things we&#39;ve covered are in the JS language itself. The reality is that most JS is written to run in and interact with environments like browsers. A good chunk of the stuff that you write in your code is, strictly speaking, not directly controlled by JavaScript. That probably sounds a little strange.</p><p>The most common non-JavaScript JavaScript you&#39;ll encounter is the DOM API. For example:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>The <code>document</code> variable exists as a global variable when your code is running in a browser. It&#39;s not provided by the JS engine, nor is it particularly controlled by the JavaScript specification. It takes the form of something that looks an awful lot like a normal JS <code>object</code>, but it&#39;s not really exactly that. It&#39;s a special <code>object,</code> often called a &quot;host object.&quot;</p><p>Moreover, the <code>getElementById(..)</code> method on <code>document</code> looks like a normal JS function, but it&#39;s just a thinly exposed interface to a built-in method provided by the DOM from your browser. In some (newer-generation) browsers, this layer may also be in JS, but traditionally the DOM and its behavior is implemented in something more like C/C++.</p><p>Another example is with input/output (I/O).</p><p>Everyone&#39;s favorite <code>alert(..)</code> pops up a message box in the user&#39;s browser window. <code>alert(..)</code> is provided to your JS program by the browser, not by the JS engine itself. The call you make sends the message to the browser internals and it handles drawing and displaying the message box.</p><p>The same goes with <code>console.log(..)</code>; your browser provides such mechanisms and hooks them up to the developer tools.</p><p>This book, and this whole series, focuses on JavaScript the language. That&#39;s why you don&#39;t see any substantial coverage of these non-JavaScript JavaScript mechanisms. Nevertheless, you need to be aware of them, as they&#39;ll be in every JS program you write!</p><h2 id="review" tabindex="-1"><a class="header-anchor" href="#review" aria-hidden="true">#</a> Review</h2><p>The first step to learning JavaScript&#39;s flavor of programming is to get a basic understanding of its core mechanisms like values, types, function closures, <code>this</code>, and prototypes.</p><p>Of course, each of these topics deserves much greater coverage than you&#39;ve seen here, but that&#39;s why they have chapters and books dedicated to them throughout the rest of this series. After you feel pretty comfortable with the concepts and code samples in this chapter, the rest of the series awaits you to really dig in and get to know the language deeply.</p><p>The final chapter of this book will briefly summarize each of the other titles in the series and the other concepts they cover besides what we&#39;ve already explored.</p>`,50);function h(s,k){return t(),o(p,null,[r,a("img",{src:s.$withBase("/you-dont-know-js-v1/up-going/fig4.png")},null,8,i),l,a("img",{src:s.$withBase("/you-dont-know-js-v1/up-going/fig5.png")},null,8,u),d,a("img",{src:s.$withBase("/you-dont-know-js-v1/up-going/fig6.png")},null,8,m),b],64)}var y=e(c,[["render",h],["__file","ch2.html.vue"]]);export{y as default};
