import{_ as n,d as s}from"./app.a957722f.js";const a={},t=s(`<h1 id="you-don-t-know-js-this-object-prototypes" tabindex="-1"><a class="header-anchor" href="#you-don-t-know-js-this-object-prototypes" aria-hidden="true">#</a> You Don&#39;t Know JS: <em>this</em> &amp; Object Prototypes</h1><h1 id="appendix-a-es6-class" tabindex="-1"><a class="header-anchor" href="#appendix-a-es6-class" aria-hidden="true">#</a> Appendix A: ES6 <code>class</code></h1><p>If there&#39;s any take-away message from the second half of this book (Chapters 4-6), it&#39;s that classes are an optional design pattern for code (not a necessary given), and that furthermore they are often quite awkward to implement in a <code>[[Prototype]]</code> language like JavaScript.</p><p>This awkwardness is <em>not</em> just about syntax, although that&#39;s a big part of it. Chapters 4 and 5 examined quite a bit of syntactic ugliness, from verbosity of <code>.prototype</code> references cluttering the code, to <em>explicit pseudo-polymorphism</em> (see Chapter 4) when you give methods the same name at different levels of the chain and try to implement a polymorphic reference from a lower-level method to a higher-level method. <code>.constructor</code> being wrongly interpreted as &quot;was constructed by&quot; and yet being unreliable for that definition is yet another syntactic ugly.</p><p>But the problems with class design are much deeper. Chapter 4 points out that classes in traditional class-oriented languages actually produce a <em>copy</em> action from parent to child to instance, whereas in <code>[[Prototype]]</code>, the action is <strong>not</strong> a copy, but rather the opposite -- a delegation link.</p><p>When compared to the simplicity of OLOO-style code and behavior delegation (see Chapter 6), which embrace <code>[[Prototype]]</code> rather than hide from it, classes stand out as a sore thumb in JS.</p><h2 id="class" tabindex="-1"><a class="header-anchor" href="#class" aria-hidden="true">#</a> <code>class</code></h2><p>But we <em>don&#39;t</em> need to re-argue that case again. I re-mention those issues briefly only so that you keep them fresh in your mind now that we turn our attention to the ES6 <code>class</code> mechanism. We&#39;ll demonstrate here how it works, and look at whether or not <code>class</code> does anything substantial to address any of those &quot;class&quot; concerns.</p><p>Let&#39;s revisit the <code>Widget</code> / <code>Button</code> example from Chapter 6:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">width<span class="token punctuation">,</span>height</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> width <span class="token operator">||</span> <span class="token number">50</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height <span class="token operator">||</span> <span class="token number">50</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>$elem <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">$where</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>$elem<span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span> <span class="token punctuation">{</span>
				<span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">+</span> <span class="token string">&quot;px&quot;</span><span class="token punctuation">,</span>
				<span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">+</span> <span class="token string">&quot;px&quot;</span>
			<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendTo</span><span class="token punctuation">(</span> $where <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Button</span> <span class="token keyword">extends</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">width<span class="token punctuation">,</span>height<span class="token punctuation">,</span>label</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">super</span><span class="token punctuation">(</span> width<span class="token punctuation">,</span> height <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>label <span class="token operator">=</span> label <span class="token operator">||</span> <span class="token string">&quot;Default&quot;</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>$elem <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span> <span class="token string">&quot;&lt;button&gt;&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>label <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">$where</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span> $where <span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>$elem<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span> <span class="token keyword">this</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">onClick</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Button &#39;&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>label <span class="token operator">+</span> <span class="token string">&quot;&#39; clicked!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>Beyond this syntax <em>looking</em> nicer, what problems does ES6 solve?</p><ol><li>There&#39;s no more (well, sorta, see below!) references to <code>.prototype</code> cluttering the code.</li><li><code>Button</code> is declared directly to &quot;inherit from&quot; (aka <code>extends</code>) <code>Widget</code>, instead of needing to use <code>Object.create(..)</code> to replace a <code>.prototype</code> object that&#39;s linked, or having to set with <code>.__proto__</code> or <code>Object.setPrototypeOf(..)</code>.</li><li><code>super(..)</code> now gives us a very helpful <strong>relative polymorphism</strong> capability, so that any method at one level of the chain can refer relatively one level up the chain to a method of the same name. This includes a solution to the note from Chapter 4 about the weirdness of constructors not belonging to their class, and so being unrelated -- <code>super()</code> works inside constructors exactly as you&#39;d expect.</li><li><code>class</code> literal syntax has no affordance for specifying properties (only methods). This might seem limiting to some, but it&#39;s expected that the vast majority of cases where a property (state) exists elsewhere but the end-chain &quot;instances&quot;, this is usually a mistake and surprising (as it&#39;s state that&#39;s implicitly &quot;shared&quot; among all &quot;instances&quot;). So, one <em>could</em> say the <code>class</code> syntax is protecting you from mistakes.</li><li><code>extends</code> lets you extend even built-in object (sub)types, like <code>Array</code> or <code>RegExp</code>, in a very natural way. Doing so without <code>class .. extends</code> has long been an exceedingly complex and frustrating task, one that only the most adept of framework authors have ever been able to accurately tackle. Now, it will be rather trivial!</li></ol><p>In all fairness, those are some substantial solutions to many of the most obvious (syntactic) issues and surprises people have with classical prototype-style code.</p><h2 id="class-gotchas" tabindex="-1"><a class="header-anchor" href="#class-gotchas" aria-hidden="true">#</a> <code>class</code> Gotchas</h2><p>It&#39;s not all bubblegum and roses, though. There are still some deep and profoundly troubling issues with using &quot;classes&quot; as a design pattern in JS.</p><p>Firstly, the <code>class</code> syntax may convince you a new &quot;class&quot; mechanism exists in JS as of ES6. <strong>Not so.</strong> <code>class</code> is, mostly, just syntactic sugar on top of the existing <code>[[Prototype]]</code> (delegation!) mechanism.</p><p>That means <code>class</code> is not actually copying definitions statically at declaration time the way it does in traditional class-oriented languages. If you change/replace a method (on purpose or by accident) on the parent &quot;class&quot;, the child &quot;class&quot; and/or instances will still be &quot;affected&quot;, in that they didn&#39;t get copies at declaration time, they are all still using the live-delegation model based on <code>[[Prototype]]</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Random: &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c1<span class="token punctuation">.</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Random: 0.4324299...&quot;</span>

<span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">rand</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Random: &quot;</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">*</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c2<span class="token punctuation">.</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Random: 867&quot;</span>

c1<span class="token punctuation">.</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Random: 432&quot; -- oops!!!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>This only seems like reasonable behavior <em>if you already know</em> about the delegation nature of things, rather than expecting <em>copies</em> from &quot;real classes&quot;. So the question to ask yourself is, why are you choosing <code>class</code> syntax for something fundamentally different from classes?</p><p>Doesn&#39;t the ES6 <code>class</code> syntax <strong>just make it harder</strong> to see and understand the difference between traditional classes and delegated objects?</p><p><code>class</code> syntax <em>does not</em> provide a way to declare class member properties (only methods). So if you need to do that to track shared state among instances, then you end up going back to the ugly <code>.prototype</code> syntax, like this:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// make sure to modify the shared state,</span>
		<span class="token comment">// not set a shadowed property on the</span>
		<span class="token comment">// instances!</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>

		<span class="token comment">// here, \`this.count\` works as expected</span>
		<span class="token comment">// via delegation</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Hello: &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// add a property for shared state directly to</span>
<span class="token comment">// prototype object</span>
<span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Hello: 1</span>

<span class="token keyword">var</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Hello: 2</span>

c1<span class="token punctuation">.</span>count <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
c1<span class="token punctuation">.</span>count <span class="token operator">===</span> c2<span class="token punctuation">.</span>count<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>The biggest problem here is that it betrays the <code>class</code> syntax by exposing (leakage!) <code>.prototype</code> as an implementation detail.</p><p>But, we also still have the surprise gotcha that <code>this.count++</code> would implicitly create a separate shadowed <code>.count</code> property on both <code>c1</code> and <code>c2</code> objects, rather than updating the shared state. <code>class</code> offers us no consolation from that issue, except (presumably) to imply by lack of syntactic support that you shouldn&#39;t be doing that <em>at all</em>.</p><p>Moreover, accidental shadowing is still a hazard:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// oops, gotcha, we&#39;re shadowing \`id()\` method</span>
		<span class="token comment">// with a property value on the instance</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;Id: &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span> <span class="token string">&quot;c1&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
c1<span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError -- \`c1.id\` is now the string &quot;c1&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>There&#39;s also some very subtle nuanced issues with how <code>super</code> works. You might assume that <code>super</code> would be bound in an analogous way to how <code>this</code> gets bound (see Chapter 2), which is that <code>super</code> would always be bound to one level higher than whatever the current method&#39;s position in the <code>[[Prototype]]</code> chain is.</p><p>However, for performance reasons (<code>this</code> binding is already expensive), <code>super</code> is not bound dynamically. It&#39;s bound sort of &quot;statically&quot;, as declaration time. No big deal, right?</p><p>Ehh... maybe, maybe not. If you, like most JS devs, start assigning functions around to different objects (which came from <code>class</code> definitions), in various different ways, you probably won&#39;t be very aware that in all those cases, the <code>super</code> mechanism under the covers is having to be re-bound each time.</p><p>And depending on what sorts of syntactic approaches you take to these assignments, there may very well be cases where the <code>super</code> can&#39;t be properly bound (at least, not where you suspect), so you may (at time of writing, TC39 discussion is ongoing on the topic) have to manually bind <code>super</code> with <code>toMethod(..)</code> (kinda like you have to do <code>bind(..)</code> for <code>this</code> -- see Chapter 2).</p><p>You&#39;re used to being able to assign around methods to different objects to <em>automatically</em> take advantage of the dynamism of <code>this</code> via the <em>implicit binding</em> rule (see Chapter 2). But the same will likely not be true with methods that use <code>super</code>.</p><p>Consider what <code>super</code> should do here (against <code>D</code> and <code>E</code>):</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">P</span> <span class="token punctuation">{</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;P.foo&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">P</span> <span class="token punctuation">{</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c1<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;P.foo&quot;</span>

<span class="token keyword">var</span> <span class="token constant">D</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;D.foo&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token constant">E</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Link E to D for delegation</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span> <span class="token constant">E</span><span class="token punctuation">,</span> <span class="token constant">D</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token constant">E</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;P.foo&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>If you were thinking (quite reasonably!) that <code>super</code> would be bound dynamically at call-time, you might expect that <code>super()</code> would automatically recognize that <code>E</code> delegates to <code>D</code>, so <code>E.foo()</code> using <code>super()</code> should call to <code>D.foo()</code>.</p><p><strong>Not so.</strong> For performance pragmatism reasons, <code>super</code> is not <em>late bound</em> (aka, dynamically bound) like <code>this</code> is. Instead it&#39;s derived at call-time from <code>[[HomeObject]].[[Prototype]]</code>, where <code>[[HomeObject]]</code> is statically bound at creation time.</p><p>In this particular case, <code>super()</code> is still resolving to <code>P.foo()</code>, since the method&#39;s <code>[[HomeObject]]</code> is still <code>C</code> and <code>C.[[Prototype]]</code> is <code>P</code>.</p><p>There will <em>probably</em> be ways to manually address such gotchas. Using <code>toMethod(..)</code> to bind/rebind a method&#39;s <code>[[HomeObject]]</code> (along with setting the <code>[[Prototype]]</code> of that object!) appears to work in this scenario:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token constant">D</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;D.foo&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Link E to D for delegation</span>
<span class="token keyword">var</span> <span class="token constant">E</span> <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> <span class="token constant">D</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// manually bind \`foo\`s \`[[HomeObject]]\` as</span>
<span class="token comment">// \`E\`, and \`E.[[Prototype]]\` is \`D\`, so thus</span>
<span class="token comment">// \`super()\` is \`D.foo()\`</span>
<span class="token constant">E</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token class-name">C</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>foo<span class="token punctuation">.</span><span class="token function">toMethod</span><span class="token punctuation">(</span> <span class="token constant">E</span><span class="token punctuation">,</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token constant">E</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;D.foo&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>Note:</strong> <code>toMethod(..)</code> clones the method, and takes <code>homeObject</code> as its first parameter (which is why we pass <code>E</code>), and the second parameter (optionally) sets a <code>name</code> for the new method (which keep at &quot;foo&quot;).</p><p>It remains to be seen if there are other corner case gotchas that devs will run into beyond this scenario. Regardless, you will have to be diligent and stay aware of which places the engine automatically figures out <code>super</code> for you, and which places you have to manually take care of it. <strong>Ugh!</strong></p><h1 id="static-dynamic" tabindex="-1"><a class="header-anchor" href="#static-dynamic" aria-hidden="true">#</a> Static &gt; Dynamic?</h1><p>But the biggest problem of all about ES6 <code>class</code> is that all these various gotchas mean <code>class</code> sorta opts you into a syntax which seems to imply (like traditional classes) that once you declare a <code>class</code>, it&#39;s a static definition of a (future instantiated) thing. You completely lose sight of the fact that <code>C</code> is an object, a concrete thing, which you can directly interact with.</p><p>In traditional class-oriented languages, you never adjust the definition of a class later, so the class design pattern doesn&#39;t suggest such capabilities. But <strong>one of the most powerful parts</strong> of JS is that it <em>is</em> dynamic, and the definition of any object is (unless you make it immutable) a fluid and mutable <em>thing</em>.</p><p><code>class</code> seems to imply you shouldn&#39;t do such things, by forcing you into the uglier <code>.prototype</code> syntax to do so, or forcing you to think about <code>super</code> gotchas, etc. It also offers <em>very little</em> support for any of the pitfalls that this dynamism can bring.</p><p>In other words, it&#39;s as if <code>class</code> is telling you: &quot;dynamic is too hard, so it&#39;s probably not a good idea. Here&#39;s a static-looking syntax, so code your stuff statically.&quot;</p><p>What a sad commentary on JavaScript: <strong>dynamic is too hard, let&#39;s pretend to be (but not actually be!) static</strong>.</p><p>These are the reasons why ES6 <code>class</code> is masquerading as a nice solution to syntactic headaches, but it&#39;s actually muddying the waters further and making things worse for JS and for clear and concise understanding.</p><p><strong>Note:</strong> If you use the <code>.bind(..)</code> utility to make a hard-bound function (see Chapter 2), the function created is not subclassable with ES6 <code>extend</code> like normal functions are.</p><h2 id="review-tl-dr" tabindex="-1"><a class="header-anchor" href="#review-tl-dr" aria-hidden="true">#</a> Review (TL;DR)</h2><p><code>class</code> does a very good job of pretending to fix the problems with the class/inheritance design pattern in JS. But it actually does the opposite: <strong>it hides many of the problems, and introduces other subtle but dangerous ones</strong>.</p><p><code>class</code> contributes to the ongoing confusion of &quot;class&quot; in JavaScript which has plagued the language for nearly two decades. In some respects, it asks more questions than it answers, and it feels in totality like a very unnatural fit on top of the elegant simplicity of the <code>[[Prototype]]</code> mechanism.</p><p>Bottom line: if ES6 <code>class</code> makes it harder to robustly leverage <code>[[Prototype]]</code>, and hides the most important nature of the JS object mechanism -- <strong>the live delegation links between objects</strong> -- shouldn&#39;t we see <code>class</code> as creating more troubles than it solves, and just relegate it to an anti-pattern?</p><p>I can&#39;t really answer that question for you. But I hope this book has fully explored the issue at a deeper level than you&#39;ve ever gone before, and has given you the information you need <em>to answer it yourself</em>.</p>`,53);function e(o,p){return t}var l=n(a,[["render",e],["__file","apA.html.vue"]]);export{l as default};
