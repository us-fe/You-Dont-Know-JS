import{_ as t,r as o,o as c,c as p,a as n,e as s,F as l,d as i,b as a}from"./app.a957722f.js";const r={},u=i(`<h1 id="you-don-t-know-js-scope-closures" tabindex="-1"><a class="header-anchor" href="#you-don-t-know-js-scope-closures" aria-hidden="true">#</a> You Don&#39;t Know JS: Scope &amp; Closures</h1><h1 id="appendix-b-polyfilling-block-scope" tabindex="-1"><a class="header-anchor" href="#appendix-b-polyfilling-block-scope" aria-hidden="true">#</a> Appendix B: Polyfilling Block Scope</h1><p>In Chapter 3, we explored Block Scope. We saw that <code>with</code> and the <code>catch</code> clause are both tiny examples of block scope that have existed in JavaScript since at least the introduction of ES3.</p><p>But it&#39;s ES6&#39;s introduction of <code>let</code> that finally gives full, unfettered block-scoping capability to our code. There are many exciting things, both functionally and code-stylistically, that block scope will enable.</p><p>But what if we wanted to use block scope in pre-ES6 environments?</p><p>Consider this code:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
	<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>This will work great in ES6 environments. But can we do so pre-ES6? <code>catch</code> is the answer.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">try</span><span class="token punctuation">{</span><span class="token keyword">throw</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Whoa! That&#39;s some ugly, weird looking code. We see a <code>try/catch</code> that appears to forcibly throw an error, but the &quot;error&quot; it throws is just a value <code>2</code>, and then the variable declaration that receives it is in the <code>catch(a)</code> clause. Mind: blown.</p><p>That&#39;s right, the <code>catch</code> clause has block-scoping to it, which means it can be used as a polyfill for block scope in pre-ES6 environments.</p><p>&quot;But...&quot;, you say. &quot;...no one wants to write ugly code like that!&quot; That&#39;s true. No one writes (some of) the code output by the CoffeeScript compiler, either. That&#39;s not the point.</p><p>The point is that tools can transpile ES6 code to work in pre-ES6 environments. You can write code using block-scoping, and benefit from such functionality, and let a build-step tool take care of producing code that will actually <em>work</em> when deployed.</p><p>This is actually the preferred migration path for all (ahem, most) of ES6: to use a code transpiler to take ES6 code and produce ES5-compatible code during the transition from pre-ES6 to ES6.</p><h2 id="traceur" tabindex="-1"><a class="header-anchor" href="#traceur" aria-hidden="true">#</a> Traceur</h2><p>Google maintains a project called &quot;Traceur&quot; <sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>, which is exactly tasked with transpiling ES6 features into pre-ES6 (mostly ES5, but not all!) for general usage. The TC39 committee relies on this tool (and others) to test out the semantics of the features they specify.</p><p>What does Traceur produce from our snippet? You guessed it!</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
	<span class="token keyword">try</span> <span class="token punctuation">{</span>
		<span class="token keyword">throw</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>So, with the use of such tools, we can start taking advantage of block scope regardless of if we are targeting ES6 or not, because <code>try/catch</code> has been around (and worked this way) from ES3 days.</p><h2 id="implicit-vs-explicit-blocks" tabindex="-1"><a class="header-anchor" href="#implicit-vs-explicit-blocks" aria-hidden="true">#</a> Implicit vs. Explicit Blocks</h2><p>In Chapter 3, we identified some potential pitfalls to code maintainability/refactorability when we introduce block-scoping. Is there another way to take advantage of block scope but to reduce this downside?</p><p>Consider this alternate form of <code>let</code>, called the &quot;let block&quot; or &quot;let statement&quot; (contrasted with &quot;let declarations&quot; from before).</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Instead of implicitly hijacking an existing block, the let-statement creates an explicit block for its scope binding. Not only does the explicit block stand out more, and perhaps fare more robustly in code refactoring, it produces somewhat cleaner code by, grammatically, forcing all the declarations to the top of the block. This makes it easier to look at any block and know what&#39;s scoped to it and not.</p><p>As a pattern, it mirrors the approach many people take in function-scoping when they manually move/hoist all their <code>var</code> declarations to the top of the function. The let-statement puts them there at the top of the block by intent, and if you don&#39;t use <code>let</code> declarations strewn throughout, your block-scoping declarations are somewhat easier to identify and maintain.</p><p>But, there&#39;s a problem. The let-statement form is not included in ES6. Neither does the official Traceur compiler accept that form of code.</p><p>We have two options. We can format using ES6-valid syntax and a little sprinkle of code discipline:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">/*let*/</span> <span class="token punctuation">{</span> <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>But, tools are meant to solve our problems. So the other option is to write explicit let statement blocks, and let a tool convert them to valid, working code.</p><p>So, I built a tool called &quot;let-er&quot; [^note-let_er] to address just this issue. <em>let-er</em> is a build-step code transpiler, but its only task is to find let-statement forms and transpile them. It will leave alone any of the rest of your code, including any let-declarations. You can safely use <em>let-er</em> as the first ES6 transpiler step, and then pass your code through something like Traceur if necessary.</p><p>Moreover, <em>let-er</em> has a configuration flag <code>--es6</code>, which when turned on (off by default), changes the kind of code produced. Instead of the <code>try/catch</code> ES3 polyfill hack, <em>let-er</em> would take our snippet and produce the fully ES6-compliant, non-hacky:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
	<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>So, you can start using <em>let-er</em> right away, and target all pre-ES6 environments, and when you only care about ES6, you can add the flag and instantly target only ES6.</p><p>And most importantly, <strong>you can use the more preferable and more explicit let-statement form</strong> even though it is not an official part of any ES version (yet).</p><h2 id="performance" tabindex="-1"><a class="header-anchor" href="#performance" aria-hidden="true">#</a> Performance</h2><p>Let me add one last quick note on the performance of <code>try/catch</code>, and/or to address the question, &quot;why not just use an IIFE to create the scope?&quot;</p><p>Firstly, the performance of <code>try/catch</code> <em>is</em> slower, but there&#39;s no reasonable assumption that it <em>has</em> to be that way, or even that it <em>always will be</em> that way. Since the official TC39-approved ES6 transpiler uses <code>try/catch</code>, the Traceur team has asked Chrome to improve the performance of <code>try/catch</code>, and they are obviously motivated to do so.</p><p>Secondly, IIFE is not a fair apples-to-apples comparison with <code>try/catch</code>, because a function wrapped around any arbitrary code changes the meaning, inside of that code, of <code>this</code>, <code>return</code>, <code>break</code>, and <code>continue</code>. IIFE is not a suitable general substitute. It could only be used manually in certain cases.</p><p>The question really becomes: do you want block-scoping, or not. If you do, these tools provide you that option. If not, keep using <code>var</code> and go on about your coding!</p>`,39),d=a("[^note-let_er]: "),h={href:"https://github.com/getify/let-er",target:"_blank",rel:"noopener noreferrer"},m=a("let-er"),k=n("hr",{class:"footnotes-sep"},null,-1),b={class:"footnotes"},f={class:"footnotes-list"},g={id:"footnote1",class:"footnote-item"},y={href:"http://google.github.io/traceur-compiler/demo/repl.html",target:"_blank",rel:"noopener noreferrer"},w=a("Google Traceur"),v=a(),_=n("a",{href:"#footnote-ref1",class:"footnote-backref"},"\u21A9\uFE0E",-1);function S(E,x){const e=o("ExternalLinkIcon");return c(),p(l,null,[u,n("p",null,[d,n("a",h,[m,s(e)])]),k,n("section",b,[n("ol",f,[n("li",g,[n("p",null,[n("a",y,[w,s(e)]),v,_])])])])],64)}var T=t(r,[["render",S],["__file","apB.html.vue"]]);export{T as default};
