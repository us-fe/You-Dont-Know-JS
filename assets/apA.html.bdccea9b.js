import{_ as n,d as a}from"./app.a957722f.js";const s={},e=a(`<h1 id="you-don-t-know-js-scope-closures" tabindex="-1"><a class="header-anchor" href="#you-don-t-know-js-scope-closures" aria-hidden="true">#</a> You Don&#39;t Know JS: Scope &amp; Closures</h1><h1 id="appendix-a-dynamic-scope" tabindex="-1"><a class="header-anchor" href="#appendix-a-dynamic-scope" aria-hidden="true">#</a> Appendix A: Dynamic Scope</h1><p>In Chapter 2, we talked about &quot;Dynamic Scope&quot; as a contrast to the &quot;Lexical Scope&quot; model, which is how scope works in JavaScript (and in fact, most other languages).</p><p>We will briefly examine dynamic scope, to hammer home the contrast. But, more importantly, dynamic scope actually is a near cousin to another mechanism (<code>this</code>) in JavaScript, which we covered in the &quot;<em>this &amp; Object Prototypes</em>&quot; title of this book series.</p><p>As we saw in Chapter 2, lexical scope is the set of rules about how the <em>Engine</em> can look-up a variable and where it will find it. The key characteristic of lexical scope is that it is defined at author-time, when the code is written (assuming you don&#39;t cheat with <code>eval()</code> or <code>with</code>).</p><p>Dynamic scope seems to imply, and for good reason, that there&#39;s a model whereby scope can be determined dynamically at runtime, rather than statically at author-time. That is in fact the case. Let&#39;s illustrate via code:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>Lexical scope holds that the RHS reference to <code>a</code> in <code>foo()</code> will be resolved to the global variable <code>a</code>, which will result in value <code>2</code> being output.</p><p>Dynamic scope, by contrast, doesn&#39;t concern itself with how and where functions and scopes are declared, but rather <strong>where they are called from</strong>. In other words, the scope chain is based on the call-stack, not the nesting of scopes in code.</p><p>So, if JavaScript had dynamic scope, when <code>foo()</code> is executed, <strong>theoretically</strong> the code below would instead result in <code>3</code> as the output.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3  (not 2!)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>How can this be? Because when <code>foo()</code> cannot resolve the variable reference for <code>a</code>, instead of stepping up the nested (lexical) scope chain, it walks up the call-stack, to find where <code>foo()</code> was <em>called from</em>. Since <code>foo()</code> was called from <code>bar()</code>, it checks the variables in scope for <code>bar()</code>, and finds an <code>a</code> there with value <code>3</code>.</p><p>Strange? You&#39;re probably thinking so, at the moment.</p><p>But that&#39;s just because you&#39;ve probably only ever worked on (or at least deeply considered) code which is lexically scoped. So dynamic scoping seems foreign. If you had only ever written code in a dynamically scoped language, it would seem natural, and lexical scope would be the odd-ball.</p><p>To be clear, JavaScript <strong>does not, in fact, have dynamic scope</strong>. It has lexical scope. Plain and simple. But the <code>this</code> mechanism is kind of like dynamic scope.</p><p>The key contrast: <strong>lexical scope is write-time, whereas dynamic scope (and <code>this</code>!) are runtime</strong>. Lexical scope cares <em>where a function was declared</em>, but dynamic scope cares where a function was <em>called from</em>.</p><p>Finally: <code>this</code> cares <em>how a function was called</em>, which shows how closely related the <code>this</code> mechanism is to the idea of dynamic scoping. To dig more into <code>this</code>, read the title &quot;<em>this &amp; Object Prototypes</em>&quot;.</p>`,17);function o(t,c){return e}var i=n(s,[["render",o],["__file","apA.html.vue"]]);export{i as default};
