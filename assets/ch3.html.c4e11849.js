import{_ as e,o as t,c as o,a as n,F as p,d as a}from"./app.a957722f.js";const c={},i=a('<h1 id="you-don-t-know-js-yet-scope-closures-2nd-edition" tabindex="-1"><a class="header-anchor" href="#you-don-t-know-js-yet-scope-closures-2nd-edition" aria-hidden="true">#</a> You Don&#39;t Know JS Yet: Scope &amp; Closures - 2nd Edition</h1><h1 id="chapter-3-the-scope-chain" tabindex="-1"><a class="header-anchor" href="#chapter-3-the-scope-chain" aria-hidden="true">#</a> Chapter 3: The Scope Chain</h1><p>Chapters 1 and 2 laid down a concrete definition of <em>lexical scope</em> (and its parts) and illustrated helpful metaphors for its conceptual foundation. Before proceeding with this chapter, find someone else to explain (written or aloud), in your own words, what lexical scope is and why it&#39;s useful to understand.</p><p>That seems like a step you might skip, but I&#39;ve found it really does help to take the time to reformulate these ideas as explanations to others. That helps our brains digest what we&#39;re learning!</p><p>Now it&#39;s time to dig into the nuts and bolts, so expect that things will get a lot more detailed from here forward. Stick with it, though, because these discussions really hammer home just how much we all <em>don&#39;t know</em> about scope, yet. Make sure to take your time with the text and all the code snippets provided.</p><p>To refresh the context of our running example, let&#39;s recall the color-coded illustration of the nested scope bubbles, from Chapter 2, Figure 2:</p>',6),l=["src"],r=n("figcaption",null,[n("em",null,"Fig. 2 (Ch. 2): Colored Scope Bubbles")],-1),u=n("br",null,null,-1),d=n("br",null,null,-1),h=a(`<p>The connections between scopes that are nested within other scopes is called the scope chain, which determines the path along which variables can be accessed. The chain is directed, meaning the lookup moves upward/outward only.</p><h2 id="lookup-is-mostly-conceptual" tabindex="-1"><a class="header-anchor" href="#lookup-is-mostly-conceptual" aria-hidden="true">#</a> &quot;Lookup&quot; Is (Mostly) Conceptual</h2><p>In Figure 2, notice the color of the <code>students</code> variable reference in the <code>for</code>-loop. How exactly did we determine that it&#39;s a RED(1) marble?</p><p>In Chapter 2, we described the runtime access of a variable as a &quot;lookup,&quot; where the <em>Engine</em> has to start by asking the current scope&#39;s <em>Scope Manager</em> if it knows about an identifier/variable, and proceeding upward/outward back through the chain of nested scopes (toward the global scope) until found, if ever. The lookup stops as soon as the first matching named declaration in a scope bucket is found.</p><p>The lookup process thus determined that <code>students</code> is a RED(1) marble, because we had not yet found a matching variable name as we traversed the scope chain, until we arrived at the final RED(1) global scope.</p><p>Similarly, <code>studentID</code> in the <code>if</code>-statement is determined to be a BLUE(2) marble.</p><p>This suggestion of a runtime lookup process works well for conceptual understanding, but it&#39;s not actually how things usually work in practice.</p><p>The color of a marble&#39;s bucket (aka, meta information of what scope a variable originates from) is <em>usually determined</em> during the initial compilation processing. Because lexical scope is pretty much finalized at that point, a marble&#39;s color will not change based on anything that can happen later during runtime.</p><p>Since the marble&#39;s color is known from compilation, and it&#39;s immutable, this information would likely be stored with (or at least accessible from) each variable&#39;s entry in the AST; that information is then used explicitly by the executable instructions that constitute the program&#39;s runtime.</p><p>In other words, <em>Engine</em> (from Chapter 2) doesn&#39;t need to lookup through a bunch of scopes to figure out which scope bucket a variable comes from. That information is already known! Avoiding the need for a runtime lookup is a key optimization benefit of lexical scope. The runtime operates more performantly without spending time on all these lookups.</p><p>But I said &quot;...usually determined...&quot; just a moment ago, with respect to figuring out a marble&#39;s color during compilation. So in what case would it ever <em>not</em> be known during compilation?</p><p>Consider a reference to a variable that isn&#39;t declared in any lexically available scopes in the current file\u2014see <em>Get Started</em>, Chapter 1, which asserts that each file is its own separate program from the perspective of JS compilation. If no declaration is found, that&#39;s not <em>necessarily</em> an error. Another file (program) in the runtime may indeed declare that variable in the shared global scope.</p><p>So the ultimate determination of whether the variable was ever appropriately declared in some accessible bucket may need to be deferred to the runtime.</p><p>Any reference to a variable that&#39;s initially <em>undeclared</em> is left as an uncolored marble during that file&#39;s compilation; this color cannot be determined until other relevant file(s) have been compiled and the application runtime commences. That deferred lookup will eventually resolve the color to whichever scope the variable is found in (likely the global scope).</p><p>However, this lookup would only be needed once per variable at most, since nothing else during runtime could later change that marble&#39;s color.</p><p>The &quot;Lookup Failures&quot; section in Chapter 2 covers what happens if a marble is ultimately still uncolored at the moment its reference is runtime executed.</p><h2 id="shadowing" tabindex="-1"><a class="header-anchor" href="#shadowing" aria-hidden="true">#</a> Shadowing</h2><p>&quot;Shadowing&quot; might sound mysterious and a little bit sketchy. But don&#39;t worry, it&#39;s completely legit!</p><p>Our running example for these chapters uses different variable names across the scope boundaries. Since they all have unique names, in a way it wouldn&#39;t matter if all of them were just stored in one bucket (like RED(1)).</p><p>Where having different lexical scope buckets starts to matter more is when you have two or more variables, each in different scopes, with the same lexical names. A single scope cannot have two or more variables with the same name; such multiple references would be assumed as just one variable.</p><p>So if you need to maintain two or more variables of the same name, you must use separate (often nested) scopes. And in that case, it&#39;s very relevant how the different scope buckets are laid out.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> studentName <span class="token operator">=</span> <span class="token string">&quot;Suzy&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">printStudent</span><span class="token punctuation">(</span><span class="token parameter">studentName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    studentName <span class="token operator">=</span> studentName<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>studentName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">printStudent</span><span class="token punctuation">(</span><span class="token string">&quot;Frank&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// FRANK</span>

<span class="token function">printStudent</span><span class="token punctuation">(</span>studentName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// SUZY</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>studentName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Suzy</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><table><thead><tr><th style="text-align:left;">TIP:</th></tr></thead><tbody><tr><td style="text-align:left;">Before you move on, take some time to analyze this code using the various techniques/metaphors we&#39;ve covered in the book. In particular, make sure to identify the marble/bubble colors in this snippet. It&#39;s good practice!</td></tr></tbody></table><p>The <code>studentName</code> variable on line 1 (the <code>var studentName = ..</code> statement) creates a RED(1) marble. The same named variable is declared as a BLUE(2) marble on line 3, the parameter in the <code>printStudent(..)</code> function definition.</p><p>What color marble will <code>studentName</code> be in the <code>studentName = studentName.toUpperCase()</code> assignment statement and the <code>console.log(studentName)</code> statement? All three <code>studentName</code> references will be BLUE(2).</p><p>With the conceptual notion of the &quot;lookup,&quot; we asserted that it starts with the current scope and works its way outward/upward, stopping as soon as a matching variable is found. The BLUE(2) <code>studentName</code> is found right away. The RED(1) <code>studentName</code> is never even considered.</p><p>This is a key aspect of lexical scope behavior, called <em>shadowing</em>. The BLUE(2) <code>studentName</code> variable (parameter) shadows the RED(1) <code>studentName</code>. So, the parameter is shadowing the (shadowed) global variable. Repeat that sentence to yourself a few times to make sure you have the terminology straight!</p><p>That&#39;s why the re-assignment of <code>studentName</code> affects only the inner (parameter) variable: the BLUE(2) <code>studentName</code>, not the global RED(1) <code>studentName</code>.</p><p>When you choose to shadow a variable from an outer scope, one direct impact is that from that scope inward/downward (through any nested scopes) it&#39;s now impossible for any marble to be colored as the shadowed variable\u2014(RED(1), in this case). In other words, any <code>studentName</code> identifier reference will correspond to that parameter variable, never the global <code>studentName</code> variable. It&#39;s lexically impossible to reference the global <code>studentName</code> anywhere inside of the <code>printStudent(..)</code> function (or from any nested scopes).</p><h3 id="global-unshadowing-trick" tabindex="-1"><a class="header-anchor" href="#global-unshadowing-trick" aria-hidden="true">#</a> Global Unshadowing Trick</h3><p>Please beware: leveraging the technique I&#39;m about to describe is not very good practice, as it&#39;s limited in utility, confusing for readers of your code, and likely to invite bugs to your program. I&#39;m covering it only because you may run across this behavior in existing programs, and understanding what&#39;s happening is critical to not getting tripped up.</p><p>It <em>is</em> possible to access a global variable from a scope where that variable has been shadowed, but not through a typical lexical identifier reference.</p><p>In the global scope (RED(1)), <code>var</code> declarations and <code>function</code> declarations also expose themselves as properties (of the same name as the identifier) on the <em>global object</em>\u2014essentially an object representation of the global scope. If you&#39;ve written JS for a browser environment, you probably recognize the global object as <code>window</code>. That&#39;s not <em>entirely</em> accurate, but it&#39;s good enough for our discussion. In the next chapter, we&#39;ll explore the global scope/object topic more.</p><p>Consider this program, specifically executed as a standalone .js file in a browser environment:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> studentName <span class="token operator">=</span> <span class="token string">&quot;Suzy&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">printStudent</span><span class="token punctuation">(</span><span class="token parameter">studentName</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>studentName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>studentName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">printStudent</span><span class="token punctuation">(</span><span class="token string">&quot;Frank&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// &quot;Frank&quot;</span>
<span class="token comment">// &quot;Suzy&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Notice the <code>window.studentName</code> reference? This expression is accessing the global variable <code>studentName</code> as a property on <code>window</code> (which we&#39;re pretending for now is synonymous with the global object). That&#39;s the only way to access a shadowed variable from inside a scope where the shadowing variable is present.</p><p>The <code>window.studentName</code> is a mirror of the global <code>studentName</code> variable, not a separate snapshot copy. Changes to one are still seen from the other, in either direction. You can think of <code>window.studentName</code> as a getter/setter that accesses the actual <code>studentName</code> variable. As a matter of fact, you can even <em>add</em> a variable to the global scope by creating/setting a property on the global object.</p><table><thead><tr><th style="text-align:left;">WARNING:</th></tr></thead><tbody><tr><td style="text-align:left;">Remember: just because you <em>can</em> doesn&#39;t mean you <em>should</em>. Don&#39;t shadow a global variable that you need to access, and conversely, avoid using this trick to access a global variable that you&#39;ve shadowed. And definitely don&#39;t confuse readers of your code by creating global variables as <code>window</code> properties instead of with formal declarations!</td></tr></tbody></table><p>This little &quot;trick&quot; only works for accessing a global scope variable (not a shadowed variable from a nested scope), and even then, only one that was declared with <code>var</code> or <code>function</code>.</p><p>Other forms of global scope declarations do not create mirrored global object properties:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> one <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> notOne <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> notTwo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">notThree</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>one<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>notOne<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>notTwo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>notThree<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Variables (no matter how they&#39;re declared!) that exist in any other scope than the global scope are completely inaccessible from a scope where they&#39;ve been shadowed:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> special <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">lookingFor</span><span class="token punctuation">(</span><span class="token parameter">special</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// The identifier \`special\` (parameter) in this</span>
    <span class="token comment">// scope is shadowed inside keepLooking(), and</span>
    <span class="token comment">// is thus inaccessible from that scope.</span>

    <span class="token keyword">function</span> <span class="token function">keepLooking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> special <span class="token operator">=</span> <span class="token number">3.141592</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>special<span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>special<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">keepLooking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">lookingFor</span><span class="token punctuation">(</span><span class="token number">112358132134</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 3.141592</span>
<span class="token comment">// 42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>The global RED(1) <code>special</code> is shadowed by the BLUE(2) <code>special</code> (parameter), and the BLUE(2) <code>special</code> is itself shadowed by the GREEN(3) <code>special</code> inside <code>keepLooking()</code>. We can still access the RED(1) <code>special</code> using the indirect reference <code>window.special</code>. But there&#39;s no way for <code>keepLooking()</code> to access the BLUE(2) <code>special</code> that holds the number <code>112358132134</code>.</p><h3 id="copying-is-not-accessing" tabindex="-1"><a class="header-anchor" href="#copying-is-not-accessing" aria-hidden="true">#</a> Copying Is Not Accessing</h3><p>I&#39;ve been asked the following &quot;But what about...?&quot; question dozens of times. Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> special <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">lookingFor</span><span class="token punctuation">(</span><span class="token parameter">special</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> another <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">special</span><span class="token operator">:</span> special
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">keepLooking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> special <span class="token operator">=</span> <span class="token number">3.141592</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>special<span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>another<span class="token punctuation">.</span>special<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Ooo, tricky!</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>special<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">keepLooking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">lookingFor</span><span class="token punctuation">(</span><span class="token number">112358132134</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 3.141592</span>
<span class="token comment">// 112358132134</span>
<span class="token comment">// 42</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>Oh! So does this <code>another</code> object technique disprove my claim that the <code>special</code> parameter is &quot;completely inaccessible&quot; from inside <code>keepLooking()</code>? No, the claim is still correct.</p><p><code>special: special</code> is copying the value of the <code>special</code> parameter variable into another container (a property of the same name). Of course, if you put a value in another container, shadowing no longer applies (unless <code>another</code> was shadowed, too!). But that doesn&#39;t mean we&#39;re accessing the parameter <code>special</code>; it means we&#39;re accessing the copy of the value it had at that moment, by way of <em>another</em> container (object property). We cannot reassign the BLUE(2) <code>special</code> parameter to a different value from inside <code>keepLooking()</code>.</p><p>Another &quot;But...!?&quot; you may be about to raise: what if I&#39;d used objects or arrays as the values instead of the numbers (<code>112358132134</code>, etc.)? Would us having references to objects instead of copies of primitive values &quot;fix&quot; the inaccessibility?</p><p>No. Mutating the contents of the object value via a reference copy is <strong>not</strong> the same thing as lexically accessing the variable itself. We still can&#39;t reassign the BLUE(2) <code>special</code> parameter.</p><h3 id="illegal-shadowing" tabindex="-1"><a class="header-anchor" href="#illegal-shadowing" aria-hidden="true">#</a> Illegal Shadowing</h3><p>Not all combinations of declaration shadowing are allowed. <code>let</code> can shadow <code>var</code>, but <code>var</code> cannot shadow <code>let</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> special <span class="token operator">=</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">;</span>

    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> special <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment">// totally fine shadowing</span>

        <span class="token comment">// ..</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">another</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ..</span>

    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> special <span class="token operator">=</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">;</span>

        <span class="token punctuation">{</span>
            <span class="token keyword">var</span> special <span class="token operator">=</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">;</span>
            <span class="token comment">// ^^^ Syntax Error</span>

            <span class="token comment">// ..</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>Notice in the <code>another()</code> function, the inner <code>var special</code> declaration is attempting to declare a function-wide <code>special</code>, which in and of itself is fine (as shown by the <code>something()</code> function).</p><p>The syntax error description in this case indicates that <code>special</code> has already been defined, but that error message is a little misleading\u2014again, no such error happens in <code>something()</code>, as shadowing is generally allowed just fine.</p><p>The real reason it&#39;s raised as a <code>SyntaxError</code> is because the <code>var</code> is basically trying to &quot;cross the boundary&quot; of (or hop over) the <code>let</code> declaration of the same name, which is not allowed.</p><p>That boundary-crossing prohibition effectively stops at each function boundary, so this variant raises no exception:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">another</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ..</span>

    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> special <span class="token operator">=</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">;</span>

        <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">&quot;https://some.url&quot;</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// totally fine shadowing</span>
            <span class="token keyword">var</span> special <span class="token operator">=</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">;</span>

            <span class="token comment">// ..</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>Summary: <code>let</code> (in an inner scope) can always shadow an outer scope&#39;s <code>var</code>. <code>var</code> (in an inner scope) can only shadow an outer scope&#39;s <code>let</code> if there is a function boundary in between.</p><h2 id="function-name-scope" tabindex="-1"><a class="header-anchor" href="#function-name-scope" aria-hidden="true">#</a> Function Name Scope</h2><p>As you&#39;ve seen by now, a <code>function</code> declaration looks like this:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">askQuestion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ..</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>And as discussed in Chapters 1 and 2, such a <code>function</code> declaration will create an identifier in the enclosing scope (in this case, the global scope) named <code>askQuestion</code>.</p><p>What about this program?</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">askQuestion</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>The same is true for the variable <code>askQuestion</code> being created. But since it&#39;s a <code>function</code> expression\u2014a function definition used as value instead of a standalone declaration\u2014the function itself will not &quot;hoist&quot; (see Chapter 5).</p><p>One major difference between <code>function</code> declarations and <code>function</code> expressions is what happens to the name identifier of the function. Consider a named <code>function</code> expression:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">askQuestion</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">ofTheTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>We know <code>askQuestion</code> ends up in the outer scope. But what about the <code>ofTheTeacher</code> identifier? For formal <code>function</code> declarations, the name identifier ends up in the outer/enclosing scope, so it may be reasonable to assume that&#39;s the case here. But <code>ofTheTeacher</code> is declared as an identifier <strong>inside the function itself</strong>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">askQuestion</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">ofTheTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ofTheTeacher<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">askQuestion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// function ofTheTeacher()...</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ofTheTeacher<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ReferenceError: ofTheTeacher is not defined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><table><thead><tr><th style="text-align:left;">NOTE:</th></tr></thead><tbody><tr><td style="text-align:left;">Actually, <code>ofTheTeacher</code> is not exactly <em>in the scope of the function</em>. Appendix A, &quot;Implied Scopes&quot; will explain further.</td></tr></tbody></table><p>Not only is <code>ofTheTeacher</code> declared inside the function rather than outside, but it&#39;s also defined as read-only:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">askQuestion</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">ofTheTeacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
    ofTheTeacher <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   <span class="token comment">// TypeError</span>

    <span class="token comment">//..</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">askQuestion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// TypeError</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Because we used strict-mode, the assignment failure is reported as a <code>TypeError</code>; in non-strict-mode, such an assignment fails silently with no exception.</p><p>What about when a <code>function</code> expression has no name identifier?</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">askQuestion</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>A <code>function</code> expression with a name identifier is referred to as a &quot;named function expression,&quot; but one without a name identifier is referred to as an &quot;anonymous function expression.&quot; Anonymous function expressions clearly have no name identifier that affects either scope.</p><table><thead><tr><th style="text-align:left;">NOTE:</th></tr></thead><tbody><tr><td style="text-align:left;">We&#39;ll discuss named vs. anonymous <code>function</code> expressions in much more detail, including what factors affect the decision to use one or the other, in Appendix A.</td></tr></tbody></table><h2 id="arrow-functions" tabindex="-1"><a class="header-anchor" href="#arrow-functions" aria-hidden="true">#</a> Arrow Functions</h2><p>ES6 added an additional <code>function</code> expression form to the language, called &quot;arrow functions&quot;:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">askQuestion</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>The <code>=&gt;</code> arrow function doesn&#39;t require the word <code>function</code> to define it. Also, the <code>( .. )</code> around the parameter list is optional in some simple cases. Likewise, the <code>{ .. }</code> around the function body is optional in some cases. And when the <code>{ .. }</code> are omitted, a return value is sent out without using a <code>return</code> keyword.</p><table><thead><tr><th style="text-align:left;">NOTE:</th></tr></thead><tbody><tr><td style="text-align:left;">The attractiveness of <code>=&gt;</code> arrow functions is often sold as &quot;shorter syntax,&quot; and that&#39;s claimed to equate to objectively more readable code. This claim is dubious at best, and I believe outright misguided. We&#39;ll dig into the &quot;readability&quot; of various function forms in Appendix A.</td></tr></tbody></table><p>Arrow functions are lexically anonymous, meaning they have no directly related identifier that references the function. The assignment to <code>askQuestion</code> creates an inferred name of &quot;askQuestion&quot;, but that&#39;s <strong>not the same thing as being non-anonymous</strong>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">askQuestion</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// ..</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

askQuestion<span class="token punctuation">.</span>name<span class="token punctuation">;</span>   <span class="token comment">// askQuestion</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Arrow functions achieve their syntactic brevity at the expense of having to mentally juggle a bunch of variations for different forms/conditions. Just a few, for example:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">42</span><span class="token punctuation">;</span>

<span class="token parameter">id</span> <span class="token operator">=&gt;</span> id<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token parameter">id<span class="token punctuation">,</span>name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> args<span class="token punctuation">[</span>args<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>The real reason I bring up arrow functions is because of the common but incorrect claim that arrow functions somehow behave differently with respect to lexical scope from standard <code>function</code> functions.</p><p>This is incorrect.</p><p>Other than being anonymous (and having no declarative form), <code>=&gt;</code> arrow functions have the same lexical scope rules as <code>function</code> functions do. An arrow function, with or without <code>{ .. }</code> around its body, still creates a separate, inner nested bucket of scope. Variable declarations inside this nested scope bucket behave the same as in a <code>function</code> scope.</p><h2 id="backing-out" tabindex="-1"><a class="header-anchor" href="#backing-out" aria-hidden="true">#</a> Backing Out</h2><p>When a function (declaration or expression) is defined, a new scope is created. The positioning of scopes nested inside one another creates a natural scope hierarchy throughout the program, called the scope chain. The scope chain controls variable access, directionally oriented upward and outward.</p><p>Each new scope offers a clean slate, a space to hold its own set of variables. When a variable name is repeated at different levels of the scope chain, shadowing occurs, which prevents access to the outer variable from that point inward.</p><p>As we step back out from these finer details, the next chapter shifts focus to the primary scope all JS programs include: the global scope.</p>`,96);function m(s,b){return t(),o(p,null,[i,n("figure",null,[n("img",{src:s.$withBase("/you-dont-know-js-v2/scope-closures/images/fig2.png"),width:"500",alt:"Colored Scope Bubbles",align:"center"},null,8,l),r,u,d]),h],64)}var f=e(c,[["render",m],["__file","ch3.html.vue"]]);export{f as default};
