import{_ as e,o as t,c as o,a as n,F as p,d as s}from"./app.a957722f.js";const c={},i=s(`<h1 id="you-don-t-know-js-yet-get-started-2nd-edition" tabindex="-1"><a class="header-anchor" href="#you-don-t-know-js-yet-get-started-2nd-edition" aria-hidden="true">#</a> You Don&#39;t Know JS Yet: Get Started - 2nd Edition</h1><h1 id="chapter-3-digging-to-the-roots-of-js" tabindex="-1"><a class="header-anchor" href="#chapter-3-digging-to-the-roots-of-js" aria-hidden="true">#</a> Chapter 3: Digging to the Roots of JS</h1><p>If you&#39;ve read Chapters 1 and 2, and taken the time to digest and percolate, you&#39;re hopefully starting to <em>get</em> JS a little more. If you skipped/skimmed them (especially Chapter 2), I recommend going back to spend some more time with that material.</p><p>In Chapter 2, we surveyed syntax, patterns, and behaviors at a high level. In this chapter, our attention shifts to some of the lower-level root characteristics of JS that underpin virtually every line of code we write.</p><p>Be aware: this chapter digs much deeper than you&#39;re likely used to thinking about a programming language. My goal is to help you appreciate the core of how JS works, what makes it tick. This chapter should begin to answer some of the &quot;Why?&quot; questions that may be cropping up as you explore JS. However, this material is still not an exhaustive exposition of the language; that&#39;s what the rest of the book series is for! Our goal here is still just to <em>get started</em>, and become more comfortable with, the <em>feel</em> of JS, how it ebbs and flows.</p><p>Don&#39;t run so quickly through this material that you get lost in the weeds. As I&#39;ve said a dozen times already, <strong>take your time</strong>. Even still, you&#39;ll probably finish this chapter with remaining questions. That&#39;s OK, because there&#39;s a whole book series ahead of you to keep exploring!</p><h2 id="iteration" tabindex="-1"><a class="header-anchor" href="#iteration" aria-hidden="true">#</a> Iteration</h2><p>Since programs are essentially built to process data (and make decisions on that data), the patterns used to step through the data have a big impact on the program&#39;s readability.</p><p>The iterator pattern has been around for decades, and suggests a &quot;standardized&quot; approach to consuming data from a source one <em>chunk</em> at a time. The idea is that it&#39;s more common and helpful to iterate the data source\u2014to progressively handle the collection of data by processing the first part, then the next, and so on, rather than handling the entire set all at once.</p><p>Imagine a data structure that represents a relational database <code>SELECT</code> query, which typically organizes the results as rows. If this query had only one or a couple of rows, you could handle the entire result set at once, and assign each row to a local variable, and perform whatever operations on that data that were appropriate.</p><p>But if the query has 100 or 1,000 (or more!) rows, you&#39;ll need iterative processing to deal with this data (typically, a loop).</p><p>The iterator pattern defines a data structure called an &quot;iterator&quot; that has a reference to an underlying data source (like the query result rows), which exposes a method like <code>next()</code>. Calling <code>next()</code> returns the next piece of data (i.e., a &quot;record&quot; or &quot;row&quot; from a database query).</p><p>You don&#39;t always know how many pieces of data that you will need to iterate through, so the pattern typically indicates completion by some special value or exception once you iterate through the entire set and <em>go past the end</em>.</p><p>The importance of the iterator pattern is in adhering to a <em>standard</em> way of processing data iteratively, which creates cleaner and easier to understand code, as opposed to having every data structure/source define its own custom way of handling its data.</p><p>After many years of various JS community efforts around mutually agreed-upon iteration techniques, ES6 standardized a specific protocol for the iterator pattern directly in the language. The protocol defines a <code>next()</code> method whose return is an object called an <em>iterator result</em>; the object has <code>value</code> and <code>done</code> properties, where <code>done</code> is a boolean that is <code>false</code> until the iteration over the underlying data source is complete.</p><h3 id="consuming-iterators" tabindex="-1"><a class="header-anchor" href="#consuming-iterators" aria-hidden="true">#</a> Consuming Iterators</h3><p>With the ES6 iteration protocol in place, it&#39;s workable to consume a data source one value at a time, checking after each <code>next()</code> call for <code>done</code> to be <code>true</code> to stop the iteration. But this approach is rather manual, so ES6 also included several mechanisms (syntax and APIs) for standardized consumption of these iterators.</p><p>One such mechanism is the <code>for..of</code> loop:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// given an iterator of some data source:</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token comment">/* .. */</span><span class="token punctuation">;</span>

<span class="token comment">// loop over its results one at a time</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> val <span class="token keyword">of</span> it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Iterator value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> val <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Iterator value: ..</span>
<span class="token comment">// Iterator value: ..</span>
<span class="token comment">// ..</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><table><thead><tr><th style="text-align:left;">NOTE:</th></tr></thead><tbody><tr><td style="text-align:left;">We&#39;ll omit the manual loop equivalent here, but it&#39;s definitely less readable than the <code>for..of</code> loop!</td></tr></tbody></table><p>Another mechanism that&#39;s often used for consuming iterators is the <code>...</code> operator. This operator actually has two symmetrical forms: <em>spread</em> and <em>rest</em> (or <em>gather</em>, as I prefer). The <em>spread</em> form is an iterator-consumer.</p><p>To <em>spread</em> an iterator, you have to have <em>something</em> to spread it into. There are two possibilities in JS: an array or an argument list for a function call.</p><p>An array spread:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// spread an iterator into an array,</span>
<span class="token comment">// with each iterated value occupying</span>
<span class="token comment">// an array element position.</span>
<span class="token keyword">var</span> vals <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token operator">...</span>it <span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>A function call spread:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// spread an iterator into a function,</span>
<span class="token comment">// call with each iterated value</span>
<span class="token comment">// occupying an argument position.</span>
<span class="token function">doSomethingUseful</span><span class="token punctuation">(</span> <span class="token operator">...</span>it <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>In both cases, the iterator-spread form of <code>...</code> follows the iterator-consumption protocol (the same as the <code>for..of</code> loop) to retrieve all available values from an iterator and place (aka, spread) them into the receiving context (array, argument list).</p><h3 id="iterables" tabindex="-1"><a class="header-anchor" href="#iterables" aria-hidden="true">#</a> Iterables</h3><p>The iterator-consumption protocol is technically defined for consuming <em>iterables</em>; an iterable is a value that can be iterated over.</p><p>The protocol automatically creates an iterator instance from an iterable, and consumes <em>just that iterator instance</em> to its completion. This means a single iterable could be consumed more than once; each time, a new iterator instance would be created and used.</p><p>So where do we find iterables?</p><p>ES6 defined the basic data structure/collection types in JS as iterables. This includes strings, arrays, maps, sets, and others.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// an array is an iterable</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> val <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Array value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> val <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Array value: 10</span>
<span class="token comment">// Array value: 20</span>
<span class="token comment">// Array value: 30</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Since arrays are iterables, we can shallow-copy an array using iterator consumption via the <code>...</code> spread operator:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> arrCopy <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token operator">...</span>arr <span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>We can also iterate the characters in a string one at a time:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> chars <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token operator">...</span>greeting <span class="token punctuation">]</span><span class="token punctuation">;</span>

chars<span class="token punctuation">;</span>
<span class="token comment">// [ &quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;,</span>
<span class="token comment">//   &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;!&quot; ]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>A <code>Map</code> data structure uses objects as keys, associating a value (of any type) with that object. Maps have a different default iteration than seen here, in that the iteration is not just over the map&#39;s values but instead its <em>entries</em>. An <em>entry</em> is a tuple (2-element array) including both a key and a value.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// given two DOM elements, \`btn1\` and \`btn2\`</span>

<span class="token keyword">var</span> buttonNames <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
buttonNames<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>btn1<span class="token punctuation">,</span><span class="token string">&quot;Button 1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
buttonNames<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>btn2<span class="token punctuation">,</span><span class="token string">&quot;Button 2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>btn<span class="token punctuation">,</span>btnName<span class="token punctuation">]</span> <span class="token keyword">of</span> buttonNames<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Clicked </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> btnName <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>In the <code>for..of</code> loop over the default map iteration, we use the <code>[btn,btnName]</code> syntax (called &quot;array destructuring&quot;) to break down each consumed tuple into the respective key/value pairs (<code>btn1</code> / <code>&quot;Button 1&quot;</code> and <code>btn2</code> / <code>&quot;Button 2&quot;</code>).</p><p>Each of the built-in iterables in JS expose a default iteration, one which likely matches your intuition. But you can also choose a more specific iteration if necessary. For example, if we want to consume only the values of the above <code>buttonNames</code> map, we can call <code>values()</code> to get a values-only iterator:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> btnName <span class="token keyword">of</span> buttonNames<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>btnName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Button 1</span>
<span class="token comment">// Button 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Or if we want the index <em>and</em> value in an array iteration, we can make an entries iterator with the <code>entries()</code> method:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>idx<span class="token punctuation">,</span>val<span class="token punctuation">]</span> <span class="token keyword">of</span> arr<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> idx <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">]: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> val <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// [0]: 10</span>
<span class="token comment">// [1]: 20</span>
<span class="token comment">// [2]: 30</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>For the most part, all built-in iterables in JS have three iterator forms available: keys-only (<code>keys()</code>), values-only (<code>values()</code>), and entries (<code>entries()</code>).</p><p>Beyond just using built-in iterables, you can also ensure your own data structures adhere to the iteration protocol; doing so means you opt into the ability to consume your data with <code>for..of</code> loops and the <code>...</code> operator. &quot;Standardizing&quot; on this protocol means code that is overall more readily recognizable and readable.</p><table><thead><tr><th style="text-align:left;">NOTE:</th></tr></thead><tbody><tr><td style="text-align:left;">You may have noticed a nuanced shift that occurred in this discussion. We started by talking about consuming <strong>iterators</strong>, but then switched to talking about iterating over <strong>iterables</strong>. The iteration-consumption protocol expects an <em>iterable</em>, but the reason we can provide a direct <em>iterator</em> is that an iterator is just an iterable of itself! When creating an iterator instance from an existing iterator, the iterator itself is returned.</td></tr></tbody></table><h2 id="closure" tabindex="-1"><a class="header-anchor" href="#closure" aria-hidden="true">#</a> Closure</h2><p>Perhaps without realizing it, almost every JS developer has made use of closure. In fact, closure is one of the most pervasive programming functionalities across a majority of languages. It might even be as important to understand as variables or loops; that&#39;s how fundamental it is.</p><p>Yet it feels kind of hidden, almost magical. And it&#39;s often talked about in either very abstract or very informal terms, which does little to help us nail down exactly what it is.</p><p>We need to be able to recognize where closure is used in programs, as the presence or lack of closure is sometimes the cause of bugs (or even the cause of performance issues).</p><p>So let&#39;s define closure in a pragmatic and concrete way:</p><blockquote><p>Closure is when a function remembers and continues to access variables from outside its scope, even when the function is executed in a different scope.</p></blockquote><p>We see two definitional characteristics here. First, closure is part of the nature of a function. Objects don&#39;t get closures, functions do. Second, to observe a closure, you must execute a function in a different scope than where that function was originally defined.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">who</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> msg <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> hello <span class="token operator">=</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> howdy <span class="token operator">=</span> <span class="token function">greeting</span><span class="token punctuation">(</span><span class="token string">&quot;Howdy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">&quot;Kyle&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Hello, Kyle!</span>

<span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">&quot;Sarah&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Hello, Sarah!</span>

<span class="token function">howdy</span><span class="token punctuation">(</span><span class="token string">&quot;Grant&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Howdy, Grant!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>First, the <code>greeting(..)</code> outer function is executed, creating an instance of the inner function <code>who(..)</code>; that function closes over the variable <code>msg</code>, which is the parameter from the outer scope of <code>greeting(..)</code>. When that inner function is returned, its reference is assigned to the <code>hello</code> variable in the outer scope. Then we call <code>greeting(..)</code> a second time, creating a new inner function instance, with a new closure over a new <code>msg</code>, and return that reference to be assigned to <code>howdy</code>.</p><p>When the <code>greeting(..)</code> function finishes running, normally we would expect all of its variables to be garbage collected (removed from memory). We&#39;d expect each <code>msg</code> to go away, but they don&#39;t. The reason is closure. Since the inner function instances are still alive (assigned to <code>hello</code> and <code>howdy</code>, respectively), their closures are still preserving the <code>msg</code> variables.</p><p>These closures are not a snapshot of the <code>msg</code> variable&#39;s value; they are a direct link and preservation of the variable itself. That means closure can actually observe (or make!) updates to these variables over time.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token parameter">step <span class="token operator">=</span> <span class="token number">1</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">increaseCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        count <span class="token operator">=</span> count <span class="token operator">+</span> step<span class="token punctuation">;</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> incBy1 <span class="token operator">=</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> incBy3 <span class="token operator">=</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">incBy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 1</span>
<span class="token function">incBy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 2</span>

<span class="token function">incBy3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 3</span>
<span class="token function">incBy3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 6</span>
<span class="token function">incBy3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 9</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>Each instance of the inner <code>increaseCount()</code> function is closed over both the <code>count</code> and <code>step</code> variables from its outer <code>counter(..)</code> function&#39;s scope. <code>step</code> remains the same over time, but <code>count</code> is updated on each invocation of that inner function. Since closure is over the variables and not just snapshots of the values, these updates are preserved.</p><p>Closure is most common when working with asynchronous code, such as with callbacks. Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getSomeData</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token function">onResponse</span><span class="token punctuation">(</span><span class="token parameter">resp</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
            <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Response (from </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> url <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">): </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> resp <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">getSomeData</span><span class="token punctuation">(</span><span class="token string">&quot;https://some.url/wherever&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Response (from https://some.url/wherever): ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>The inner function <code>onResponse(..)</code> is closed over <code>url</code>, and thus preserves and remembers it until the Ajax call returns and executes <code>onResponse(..)</code>. Even though <code>getSomeData(..)</code> finishes right away, the <code>url</code> parameter variable is kept alive in the closure for as long as needed.</p><p>It&#39;s not necessary that the outer scope be a function\u2014it usually is, but not always\u2014just that there be at least one variable in an outer scope accessed from an inner function:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>idx<span class="token punctuation">,</span>btn<span class="token punctuation">]</span> <span class="token keyword">of</span> buttons<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Clicked on button (</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> idx <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)!</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Because this loop is using <code>let</code> declarations, each iteration gets new block-scoped (aka, local) <code>idx</code> and <code>btn</code> variables; the loop also creates a new inner <code>onClick(..)</code> function each time. That inner function closes over <code>idx</code>, preserving it for as long as the click handler is set on the <code>btn</code>. So when each button is clicked, its handler can print its associated index value, because the handler remembers its respective <code>idx</code> variable.</p><p>Remember: this closure is not over the value (like <code>1</code> or <code>3</code>), but over the variable <code>idx</code> itself.</p><p>Closure is one of the most prevalent and important programming patterns in any language. But that&#39;s especially true of JS; it&#39;s hard to imagine doing anything useful without leveraging closure in one way or another.</p><p>If you&#39;re still feeling unclear or shaky about closure, the majority of Book 2, <em>Scope &amp; Closures</em> is focused on the topic.</p><h2 id="this-keyword" tabindex="-1"><a class="header-anchor" href="#this-keyword" aria-hidden="true">#</a> <code>this</code> Keyword</h2><p>One of JS&#39;s most powerful mechanisms is also one of its most misunderstood: the <code>this</code> keyword. One common misconception is that a function&#39;s <code>this</code> refers to the function itself. Because of how <code>this</code> works in other languages, another misconception is that <code>this</code> points the instance that a method belongs to. Both are incorrect.</p><p>As discussed previously, when a function is defined, it is <em>attached</em> to its enclosing scope via closure. Scope is the set of rules that controls how references to variables are resolved.</p><p>But functions also have another characteristic besides their scope that influences what they can access. This characteristic is best described as an <em>execution context</em>, and it&#39;s exposed to the function via its <code>this</code> keyword.</p><p>Scope is static and contains a fixed set of variables available at the moment and location you define a function, but a function&#39;s execution <em>context</em> is dynamic, entirely dependent on <strong>how it is called</strong> (regardless of where it is defined or even called from).</p><p><code>this</code> is not a fixed characteristic of a function based on the function&#39;s definition, but rather a dynamic characteristic that&#39;s determined each time the function is called.</p><p>One way to think about the <em>execution context</em> is that it&#39;s a tangible object whose properties are made available to a function while it executes. Compare that to scope, which can also be thought of as an <em>object</em>; except, the <em>scope object</em> is hidden inside the JS engine, it&#39;s always the same for that function, and its <em>properties</em> take the form of identifier variables available inside the function.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">classroom</span><span class="token punctuation">(</span><span class="token parameter">teacher</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
            <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> teacher <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> says to study </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>topic <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> assignment <span class="token operator">=</span> <span class="token function">classroom</span><span class="token punctuation">(</span><span class="token string">&quot;Kyle&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>The outer <code>classroom(..)</code> function makes no reference to a <code>this</code> keyword, so it&#39;s just like any other function we&#39;ve seen so far. But the inner <code>study()</code> function does reference <code>this</code>, which makes it a <code>this</code>-aware function. In other words, it&#39;s a function that is dependent on its <em>execution context</em>.</p><table><thead><tr><th style="text-align:left;">NOTE:</th></tr></thead><tbody><tr><td style="text-align:left;"><code>study()</code> is also closed over the <code>teacher</code> variable from its outer scope.</td></tr></tbody></table><p>The inner <code>study()</code> function returned by <code>classroom(&quot;Kyle&quot;)</code> is assigned to a variable called <code>assignment</code>. So how can <code>assignment()</code> (aka <code>study()</code>) be called?</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">assignment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Kyle says to study undefined  -- Oops :(</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>In this snippet, we call <code>assignment()</code> as a plain, normal function, without providing it any <em>execution context</em>.</p><p>Since this program is not in strict mode (see Chapter 1, &quot;Strictly Speaking&quot;), context-aware functions that are called <strong>without any context specified</strong> default the context to the global object (<code>window</code> in the browser). As there is no global variable named <code>topic</code> (and thus no such property on the global object), <code>this.topic</code> resolves to <code>undefined</code>.</p><p>Now consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> homework <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">topic</span><span class="token operator">:</span> <span class="token string">&quot;JS&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">assignment</span><span class="token operator">:</span> assignment
<span class="token punctuation">}</span><span class="token punctuation">;</span>

homework<span class="token punctuation">.</span><span class="token function">assignment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Kyle says to study JS</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>A copy of the <code>assignment</code> function reference is set as a property on the <code>homework</code> object, and then it&#39;s called as <code>homework.assignment()</code>. That means the <code>this</code> for that function call will be the <code>homework</code> object. Hence, <code>this.topic</code> resolves to <code>&quot;JS&quot;</code>.</p><p>Lastly:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> otherHomework <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">topic</span><span class="token operator">:</span> <span class="token string">&quot;Math&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">assignment</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>otherHomework<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Kyle says to study Math</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>A third way to invoke a function is with the <code>call(..)</code> method, which takes an object (<code>otherHomework</code> here) to use for setting the <code>this</code> reference for the function call. The property reference <code>this.topic</code> resolves to <code>&quot;Math&quot;</code>.</p><p>The same context-aware function invoked three different ways, gives different answers each time for what object <code>this</code> will reference.</p><p>The benefit of <code>this</code>-aware functions\u2014and their dynamic context\u2014is the ability to more flexibly re-use a single function with data from different objects. A function that closes over a scope can never reference a different scope or set of variables. But a function that has dynamic <code>this</code> context awareness can be quite helpful for certain tasks.</p><h2 id="prototypes" tabindex="-1"><a class="header-anchor" href="#prototypes" aria-hidden="true">#</a> Prototypes</h2><p>Where <code>this</code> is a characteristic of function execution, a prototype is a characteristic of an object, and specifically resolution of a property access.</p><p>Think about a prototype as a linkage between two objects; the linkage is hidden behind the scenes, though there are ways to expose and observe it. This prototype linkage occurs when an object is created; it&#39;s linked to another object that already exists.</p><p>A series of objects linked together via prototypes is called the &quot;prototype chain.&quot;</p><p>The purpose of this prototype linkage (i.e., from an object B to another object A) is so that accesses against B for properties/methods that B does not have, are <em>delegated</em> to A to handle. Delegation of property/method access allows two (or more!) objects to cooperate with each other to perform a task.</p><p>Consider defining an object as a normal literal:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> homework <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">topic</span><span class="token operator">:</span> <span class="token string">&quot;JS&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>The <code>homework</code> object only has a single property on it: <code>topic</code>. However, its default prototype linkage connects to the <code>Object.prototype</code> object, which has common built-in methods on it like <code>toString()</code> and <code>valueOf()</code>, among others.</p><p>We can observe this prototype linkage <em>delegation</em> from <code>homework</code> to <code>Object.prototype</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>homework<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [object Object]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>homework.toString()</code> works even though <code>homework</code> doesn&#39;t have a <code>toString()</code> method defined; the delegation invokes <code>Object.prototype.toString()</code> instead.</p><h3 id="object-linkage" tabindex="-1"><a class="header-anchor" href="#object-linkage" aria-hidden="true">#</a> Object Linkage</h3><p>To define an object prototype linkage, you can create the object using the <code>Object.create(..)</code> utility:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> homework <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">topic</span><span class="token operator">:</span> <span class="token string">&quot;JS&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> otherHomework <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>homework<span class="token punctuation">)</span><span class="token punctuation">;</span>

otherHomework<span class="token punctuation">.</span>topic<span class="token punctuation">;</span>   <span class="token comment">// &quot;JS&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>The first argument to <code>Object.create(..)</code> specifies an object to link the newly created object to, and then returns the newly created (and linked!) object.</p><p>Figure 4 shows how the three objects (<code>otherHomework</code>, <code>homework</code>, and <code>Object.prototype</code>) are linked in a prototype chain:</p>`,110),r=["src"],l=n("figcaption",null,[n("em",null,"Fig. 4: Objects in a prototype chain")],-1),u=n("br",null,null,-1),d=n("br",null,null,-1),h=s(`<p>Delegation through the prototype chain only applies for accesses to lookup the value in a property. If you assign to a property of an object, that will apply directly to the object regardless of where that object is prototype linked to.</p><table><thead><tr><th style="text-align:left;">TIP:</th></tr></thead><tbody><tr><td style="text-align:left;"><code>Object.create(null)</code> creates an object that is not prototype linked anywhere, so it&#39;s purely just a standalone object; in some circumstances, that may be preferable.</td></tr></tbody></table><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>homework<span class="token punctuation">.</span>topic<span class="token punctuation">;</span>
<span class="token comment">// &quot;JS&quot;</span>

otherHomework<span class="token punctuation">.</span>topic<span class="token punctuation">;</span>
<span class="token comment">// &quot;JS&quot;</span>

otherHomework<span class="token punctuation">.</span>topic <span class="token operator">=</span> <span class="token string">&quot;Math&quot;</span><span class="token punctuation">;</span>
otherHomework<span class="token punctuation">.</span>topic<span class="token punctuation">;</span>
<span class="token comment">// &quot;Math&quot;</span>

homework<span class="token punctuation">.</span>topic<span class="token punctuation">;</span>
<span class="token comment">// &quot;JS&quot; -- not &quot;Math&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>The assignment to <code>topic</code> creates a property of that name directly on <code>otherHomework</code>; there&#39;s no effect on the <code>topic</code> property on <code>homework</code>. The next statement then accesses <code>otherHomework.topic</code>, and we see the non-delegated answer from that new property: <code>&quot;Math&quot;</code>.</p><p>Figure 5 shows the objects/properties after the assignment that creates the <code>otherHomework.topic</code> property:</p>`,6),k=["src"],m=n("figcaption",null,[n("em",null,"Fig. 5: Shadowed property 'topic'")],-1),b=n("br",null,null,-1),g=n("br",null,null,-1),f=s(`<p>The <code>topic</code> on <code>otherHomework</code> is &quot;shadowing&quot; the property of the same name on the <code>homework</code> object in the chain.</p><table><thead><tr><th style="text-align:left;">NOTE:</th></tr></thead><tbody><tr><td style="text-align:left;">Another frankly more convoluted but perhaps still more common way of creating an object with a prototype linkage is using the &quot;prototypal class&quot; pattern, from before <code>class</code> (see Chapter 2, &quot;Classes&quot;) was added in ES6. We&#39;ll cover this topic in more detail in Appendix A, &quot;Prototypal &#39;Classes&#39;&quot;.</td></tr></tbody></table><h3 id="this-revisited" tabindex="-1"><a class="header-anchor" href="#this-revisited" aria-hidden="true">#</a> <code>this</code> Revisited</h3><p>We covered the <code>this</code> keyword earlier, but its true importance shines when considering how it powers prototype-delegated function calls. Indeed, one of the main reasons <code>this</code> supports dynamic context based on how the function is called is so that method calls on objects which delegate through the prototype chain still maintain the expected <code>this</code>.</p><p>Consider:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> homework <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Please study </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>topic <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> jsHomework <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>homework<span class="token punctuation">)</span><span class="token punctuation">;</span>
jsHomework<span class="token punctuation">.</span>topic <span class="token operator">=</span> <span class="token string">&quot;JS&quot;</span><span class="token punctuation">;</span>
jsHomework<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Please study JS</span>

<span class="token keyword">var</span> mathHomework <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>homework<span class="token punctuation">)</span><span class="token punctuation">;</span>
mathHomework<span class="token punctuation">.</span>topic <span class="token operator">=</span> <span class="token string">&quot;Math&quot;</span><span class="token punctuation">;</span>
mathHomework<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Please study Math</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>The two objects <code>jsHomework</code> and <code>mathHomework</code> each prototype link to the single <code>homework</code> object, which has the <code>study()</code> function. <code>jsHomework</code> and <code>mathHomework</code> are each given their own <code>topic</code> property (see Figure 6).</p>`,7),y=["src"],v=n("figcaption",null,[n("em",null,"Fig. 6: Two objects linked to a common parent")],-1),w=n("br",null,null,-1),j=n("br",null,null,-1),q=s('<p><code>jsHomework.study()</code> delegates to <code>homework.study()</code>, but its <code>this</code> (<code>this.topic</code>) for that execution resolves to <code>jsHomework</code> because of how the function is called, so <code>this.topic</code> is <code>&quot;JS&quot;</code>. Similarly for <code>mathHomework.study()</code> delegating to <code>homework.study()</code> but still resolving <code>this</code> to <code>mathHomework</code>, and thus <code>this.topic</code> as <code>&quot;Math&quot;</code>.</p><p>The preceding code snippet would be far less useful if <code>this</code> was resolved to <code>homework</code>. Yet, in many other languages, it would seem <code>this</code> would be <code>homework</code> because the <code>study()</code> method is indeed defined on <code>homework</code>.</p><p>Unlike many other languages, JS&#39;s <code>this</code> being dynamic is a critical component of allowing prototype delegation, and indeed <code>class</code>, to work as expected!</p><h2 id="asking-why" tabindex="-1"><a class="header-anchor" href="#asking-why" aria-hidden="true">#</a> Asking &quot;Why?&quot;</h2><p>The intended take-away from this chapter is that there&#39;s a lot more to JS under the hood than is obvious from glancing at the surface.</p><p>As you are <em>getting started</em> learning and knowing JS more closely, one of the most important skills you can practice and bolster is curiosity, and the art of asking &quot;Why?&quot; when you encounter something in the language.</p><p>Even though this chapter has gone quite deep on some of the topics, many details have still been entirely skimmed over. There&#39;s much more to learn here, and the path to that starts with you asking the <em>right</em> questions of your code. Asking the right questions is a critical skill of becoming a better developer.</p><p>In the final chapter of this book, we&#39;re going to briefly look at how JS is divided, as covered across the rest of the <em>You Don&#39;t Know JS Yet</em> book series. Also, don&#39;t skip Appendix B of this book, which has some practice code to review some of the main topics covered in this book.</p>',8);function x(a,S){return t(),o(p,null,[i,n("figure",null,[n("img",{src:a.$withBase("/you-dont-know-js-v2/get-started/images/fig4.png"),width:"200",alt:"Prototype chain with 3 objects",align:"center"},null,8,r),l,u,d]),h,n("figure",null,[n("img",{src:a.$withBase("/you-dont-know-js-v2/get-started/images/fig5.png"),width:"200",alt:"3 objects linked, with shadowed property",align:"center"},null,8,k),m,b,g]),f,n("figure",null,[n("img",{src:a.$withBase("/you-dont-know-js-v2/get-started/images/fig6.png"),width:"495",alt:"4 objects prototype linked",align:"center"},null,8,y),v,w,j]),q],64)}var _=e(c,[["render",x],["__file","ch3.html.vue"]]);export{_ as default};
